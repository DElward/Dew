/***************************************************************/
/*  chelp.h                                                    */
/*      Generated: 07-Jul-2014 11:46:10                        */
/***************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

char * get_help_src(void) { return ("H 07-Jul-2014 11:46:10"); }

static char * chelp_text_index[] = {
  "Desh is a new shell and command language interpreter that executes commands",
  "read from the standard input or from a file.  It has some features that are similar",
  "to other shells (such as bash POSIX shells), however most implementation",
  "details differ from standard shells.",
  "",
  "For more information, enter: help <topic>",
  "",
  "<topic> may be any command name or:",
  "",
  "    _commands_        _datefmts_        _desh_            _errors_",
  "_expfunctions_",
  "_expressions_",
  "_intro_",
  "_keyboard_",
  "_parsing_",
  "_redirection_",
  "_scripting_",
  "_shells_",
  "_substitution_",
  "_userfunctions_",
  "_variables_",
  "",
  "New users may wish to start with: help intro",
  "",
  "Examples:   help commands",
  "            help dir",
  "",
NULL
};

static char * chelp_text_commands[] = {
  "desh commands",
  "",
  "In desh (as in other shells), the first token on a line is interpreted as",
  "the command.  Tokens after the first are considered arguments to the",
  "command.",
  "",
  "The desh built-in commands are:",
  "",
  "    _call_          _catch_         _cd_            _chmod_         _copy_",
  "_dir_",
  "_dot_ (.)",
  "_echo_",
  "_else_",
  "_endfor_",
  "_endfunction_",
  "_endif_",
  "_endtry_",
  "_endwhile_",
  "_exit_",
  "_export_",
  "_for_",
  "_function_",
  "_help_",
  "_if_",
  "_mkdir_",
  "_move_",
  "_remove_",
  "_removedir_",
  "_return_",
  "_rmdir_",
  "_set_",
  "_shift_",
  "_shopt_",
  "_start_",
  "_throw_",
  "_time_",
  "_try_",
  "_type_",
  "_wait_",
  "_while_",
  "",
  "Desh searches for commands in following order:",
  "",
  "    1.      Internal.  If the command is a desh built-in command, it is executed.",
  "",
  "    2.      User function.  If the command is a user defined function, it is executed.",
  "",
  "    3.      PATH.  If the command is neither a desh built-in command, nor a",
  "user defined function, directories are searched in the order indicated by the PATH",
  "variable (as in other shells).  On Windows systems, the PATHEXT variable is also",
  "used to search for executable files based on their extension.",
  "",
  "Comments may be placed at the beginning or end of a line using a pound sign (#).",
  "For example:",
  "",
  "    # This is a comment line",
  "    copy ab cd    # And this is a copy command with a comment",
  "",
  "Desh commands are terminated with a semicolon (;) or a new line.  Long lines may be continued",
  "with a circumflex (^).  Examples:",
  "",
  "    set A=1; set B=2; set B=3",
  "    copy ^",
  "        long_source_file_name ^",
  "        long_target_file_name",
  "",
  "Desh command options are usually in the form of -<char> like in Unix.",
  "For example:",
  "",
  "    copy -y src tgt",
  "",
  "    The -y option causes the copy command to do the copy even if the",
  "target file already exits.",
  "",
NULL
};

static char * chelp_text_errors[] = {
  "error handling",
  "",
  "An unhandled error while processing a script causes command",
  "processing to halt.  This prevents scripts that encounter an",
  "error from creating more errors and possibly doing real harm.",
  "It is an important principle that errors be caught soon and not",
  "go on to create more errors.",
  "",
  "try/catch commands",
  "",
  "    To \"handle\" an error in desh, the try command is used.  There",
  "are three ways the try command may be used.  They are:",
  "",
  "        1. try <command>",
  "",
  "        2. try",
  "                <command-list>",
  "           endtry",
  "",
  "        3. try",
  "                <command-list>",
  "           catch",
  "                <recovery-commands>",
  "           endtry",
  "",
  "",
  "    In 1, one command is tried and if it fails command processing continues.",
  "The try command has a -q option that inhibits the display of an error message.",
  "If, for example, you wished to remove MyFile001, but didn't care if it was",
  "there or not, you could use the command:",
  "",
  "            try -q remove MyFile001",
  "",
  "    In 2, any number of commands are tried and if any of them fails,",
  "command processing continues after the endtry.  Any commands between",
  "the command with the error and the endtry are skipped.",
  "",
  "    In 3, any number of commands are tried and if any of them fails,",
  "command processing continues after the catch where recovery commands",
  "are executed.  Any commands between the command with the error and the",
  "catch are skipped.  If no command between the try and the catch has an error,",
  "then commands between the catch and endtry are skipped.",
  "",
  "throw command",
  "",
  "    In desh, most errors happen during command execution.  However,",
  "sometimes a script will detect something is wrong and need to create",
  "an error condition.  The throw command is used to create an error condition.",
  "The syntax of throw is:",
  "",
  "        throw [ <string expression> ]",
  "",
  "    The throw command is often used after a catch command to create a new error",
  "after an error has already been caught.  This allows a custom error message",
  "to be displayed while the throw command is used to pass the error on.",
  "",
  "Variables",
  "",
  "    When a command has an error, three variables are automatically set:",
  "",
  "        ERRCMD      Has the command that caused the error.",
  "",
  "        ERRMSG      Has the error message.",
  "",
  "        ERRNUM      Has the desh error number.",
  "",
  "    These variables are often used in after a catch to either examine with",
  "an if, or displayed with an echo.",
  "",
  "Nesting",
  "",
  "    The try command may be nested either after a try or after a catch. Also,",
  "try can catch errors in user functions, even if the function call nesting",
  "is deep.",
  "",
  "Example:",
  "",
  "    The following example catches an error while copying aaa, bbb, or ccc.",
  "The catch displays information about the error using error variables,",
  "then passes the error on using throw.",
  "",
  "        try -q",
  "            copy aaa xxx",
  "            copy bbb yyy",
  "        catch",
  "            echo Error command: $ERRCMD",
  "            echo Error number : $ERRNUM",
  "            echo Error message: $ERRMSG",
  "            throw \"Command failed.\"",
  "        endtry",
  "",
  "See also:       _catch_, _throw_, _try_",
  "",
  "",
NULL
};

static char * chelp_text_datefmts[] = {
  "date formats",
  "",
  "Date formats are used to describe a date in the built-in expression",
  "functions: addtodate(), now(), subdates() and subfromdate().",
  "Date formats are a string describing the date using a percent sign (%)",
  "for individual date items.  For example \"%m\" refers to a month",
  "number from 1 to 12.  Several date items are often used in a date format.",
  "For example, a date format of MM/DD/YYYY is \"%m/%d/%Y\".  Date formats",
  "are CASE SENSITIVE.  For example, \"%m\" refers to a month, but \"%M\"",
  "refers to a minute.  However, conversions from a date format are",
  "case insensitive.  For example, using a \"%b\" item, \"May\", \"may\"",
  "and \"MAY\" all all the same.",
  "",
  "Date format items:",
  "",
  "    %%          Percent sign",
  "    %a          Abbreviated 3 character weekday name (Sun, Mon, ...)",
  "    %A          Full 9 character weekday name (Monday   , Tuesday  , ...,)",
  "    %b          Abbreviated 3 character month name (Jan, Feb, ....)",
  "    %B          Full 9 character month name (January  , February , ...,)",
  "    %C          BC/AD indicator for year (AD or BC)",
  "    %d          Day of month number (01 - 31)",
  "    %E          Day number from Jan 1, 1900 as in Microsoft Excel",
  "    %H          Hour in 24-hour format (00 - 23)",
  "    %I          Hour in 12-hour format (01 - 12)",
  "    %j          Day of year number (001 - 366)",
  "    %J          Julian day beginning January 1, 4713 BC",
  "    %m          Month number (01 - 12)",
  "    %M          Minute number (00 - 59)",
  "    %nd         Total number of days in interval (may be negative)",
  "    %nH         Total number of hours in interval (may be negative)",
  "    %nM         Total number of minutes in interval (may be negative)",
  "    %nS         Total number of seconds in interval (may be negative)",
  "    %ny         2-digit year in interval (may be negative)",
  "    %nY         4-digit year in interval (may be negative)",
  "    %S          Second number (00 - 59)",
  "    %te         Time of day from 12:00 AM (Microsoft Excel format)",
  "    %tj         Time of day from 12:00 PM (Julian time)",
  "    %y          Year without century, number (00 - 99)",
  "    %Y          Year with century as YYYY number",
  "    %p          AM/PM indicator for 12-hour clock (AM or PM)",
  "    space       A space character in the date.",
  "    /           A slash (/) character in the date.",
  "    -           A hyphen (-) character in the date.",
  "    :           A colon (:) character in the date.",
  "    <char>      The <char> in the date.",
  "",
  "Examples:       set this_date = now(\"%m/%d/%Y\")",
  "",
  "                    Sets the variable this_date to the current date",
  "in MM/DD/YYYY format, e.g. \"02/20/2013\"",
  "",
  "                set this_mdy = now(\"%m/%d/%Y\")",
  "                set ymd=addtodate(this_mdy, \"%m/%d/%Y\", 0, \"%nd\", \"%Y%m%d\")",
  "",
  "                    Sets the variable this_mdy to the current date",
  "in MM/DD/YYYY format, then uses addtodate() to reformat this_mdy into",
  "YYYYMMDD by adding zero days.",
  "",
  "                echo It is now ${now(\"%a, %b %d, %Y %I:%M %p\")}",
  "",
  "                    Shows the current date and time using now() in",
  "an expression substitution.  The output will look like:",
  "",
  "                        It is now Thu, Feb 21, 2013 04:27 PM",
  "",
  "See also:        _addtodate_, _now_, _subdates_, _subfromdate_",
  "",
NULL
};

static char * chelp_text_desh[] = {
  "desh",
  "",
  "Running desh",
  "",
  "    When desh is run from outside desh, the syntax is:",
  "",
  "Syntax:             desh [-<opt> [...] ] [ <script> ] [ <script arg> [...] ]",
  "",
  "    <script>        The name of the desh script file to execute.  This must be",
  "a text file containing desh commands.",
  "",
  "    <script arg>    The first argument to <script>.  The script may access this",
  "argument with $1.  Additional arguments may be supplied and accessed by the",
  "script as $2, $3, etc.",
  "",
  "    Options:        Below is a brief description of each option.  For a more",
  "complete description, see _shopt_.",
  "",
  "        a           Display abbreviated version number.",
  "        c           Execute first argument as a command then exit.",
  "        d           Display extra debugging information.",
  "        f           Expand filesets such as *.",
  "        i           Case insensitive command and variable names.",
  "        n           Inhibit execution of deshrc.",
  "        p           Pause for input before exiting.",
  "        v           Verbose. Display debugging information.",
  "        w           Causes Windows behavior.",
  "        x           Exit after processing command line.",
  "",
  "deshrc",
  "",
  "    When desh is started, before running the command line script, it looks",
  "for a startup script file called deshrc in the home directory of the",
  "user running desh (unless -n is specified).  If deshrc is not found,",
  "it looks for an alternate file depending on Windows or Unix.  The alternate",
  "file on Windows is deshrc.ini. The alternate file on Unix is .deshrc.",
  "If either deshrc or the alternate is found, that script is run before",
  "the command line script (if any).",
  "",
NULL
};

static char * chelp_text_expfunctions[] = {
  "expression functions",
  "",
  "Expression functions are built into desh and are available in any",
  "desh expression.  The list of built-in desh functions is here with",
  "full descriptions below.",
  "",
  "    _addtodate_         Adds an interval to a date and returns a date.",
  "    _argv_              Returns the function/program argument n.",
  "    _basename_          Returns the non-directory portion of a path name.",
  "    _char_              Returns the ASCII character from a number.",
  "    _chbase_            Returns string of number converted to another base",
  "    _code_              Returns the ASCII code of a character.",
  "    _dirname_           Returns the directory portion of a path name.",
  "    _extname_           Returns the extension of a path name with leading dot.",
  "    _find_              Returns index of string within another string",
  "    _finfo_             Returns information about a file or directory.",
  "    _left_              Returns characters from the left of a string.",
  "    _len_               Returns the length of a character string.",
  "    _lower_             Returns the string in all lower case characters",
  "    _matches_           Returns TRUE if a string matches a pattern",
  "    _mid_               Returns characters from the middle of a string.",
  "    _now_               Returns the current date and time.",
  "    _prompt_            Returns characters entered by user",
  "    _rept_              Return a repeated string..",
  "    _right_             Returns characters from the right of a string.",
  "    _subdates_          Subtracts two dates and returns an interval.",
  "    _trim_              Strips leading and trailing spaces from a string.",
  "    _subfromdate_       Subtracts an interval from a date and returns a date.",
  "    _upper_             Returns the string in all upper case characters",
  "",
  "See also:       _expressions_,  _parsing_, _for_",
  "",
NULL
};

static char * chelp_text_expressions[] = {
  "desh expressions",
  "",
  "Desh expressions are similar to expressions in other programming languages.",
  "Expressions are available in several commands such as set and if,",
  "and in expression substitution using ${exp}.  There is support for",
  "operators, order of precedence, grouping with parentheses, variables and",
  "functions with both built-in and user defined functions.",
  "",
  "Data Types",
  "",
  "    Desh supports three data types: numbers (integers), strings and",
  "Boolean (true/false). However, desh expressions are not strongly",
  "data typed, and there is automatic data type conversion depending",
  "on the context.  Take, for example:",
  "",
  "        \"0012\" & \"01\"",
  "",
  "    The \"&\" operator does string concatenation, so the result is \"001201\".  But",
  "look at this expression:",
  "",
  "        \"0012\" + \"01\"",
  "",
  "    The \"+\" operator does numeric addition, so the result is 13.",
  "",
  "    An error occurs when an operand cannot be converted to the required data",
  "type.  For example: \"12\" * \"8\" is valid, but \"12\" * \"xyz\" generates an error because",
  "\"xyz\" is not a number.",
  "",
  "Literals",
  "",
  "    Boolean     The two Boolean literals are true and false, which must be in lower",
  "case unless the -i shell option is in effect (the default on Windows).  However,",
  "Boolean literals may also be specified using numeric or string literals which",
  "then take advantage of automatic data type conversion.  Non-zero numbers are",
  "converted to true and zero is converted to false.  The following strings",
  "are converted to true always with case insensitive comparison: \"TRUE\",",
  "\"T\", \"YES\", \"Y\".  Likewise, these strings are converted to false: \"FALSE\",",
  "\"F\", \"NO\", \"N\".",
  "",
  "    Numbers     Numeric literals must be integers consisting of only digits with a",
  "maximum of 9223372036854775807. Numeric literals may also be specified in",
  "hexadecimal by prefixing the number with 0x.  Thus 0x1f is interpreted as 31.",
  "",
  "    String      String literals must be enclosed in either single (') or double (\")",
  "quotation marks.  The difference between the two is that using single quotation marks",
  "inhibits variable substitution in the quoted string, but double quotes permit",
  "variable substitution in the quoted string.",
  "",
  "Operators",
  "",
  "    The order of precedence of operators is:",
  "",
  "        1. ( )          Parentheses for grouping",
  "",
  "        2. + (unary)    Unary positive",
  "           - (unary)    Unary negative",
  "           not          Logical (true/false) NOT",
  "",
  "        3. *            Numeric multiplication",
  "           /            Numeric division",
  "           %            Numeric modulus (remainder)*",
  "",
  "        4. +            Numeric addition",
  "           -            Numeric subtraction",
  "           &            String concatenation",
  "",
  "        5. =            Comparison for equal",
  "           <            Comparison for less than",
  "           <=           Comparison for less than or equal",
  "           >            Comparison for greater than",
  "           >=           Comparison for less than or equal",
  "           <>           Comparison for not equal",
  "",
  "        6. and          Logical (true/false) AND",
  "",
  "        7. or           Logical (true/false) OR",
  "",
  "    Operators with the same order of precedence are evaluated left to right.",
  "",
  "    It is an error to divide by zero, or take the modulus of zero.",
  "",
  "    ** Modulus result has the same sign as dividend. See:",
  "    _http://en.wikipedia.org/wiki/Modulo__operation_",
  "",
  "Partial Expression Evaluation",
  "",
  "    If the first part of a OR expression is true,",
  "the second part of the expression is not evaluated because the whole",
  "expression must be true.  Similarly, if the first part of an AND",
  "expression is false, the second part of the expression is not",
  "evaluated because the whole expression must be false.",
  "",
  "Expression Examples:",
  "",
  "    The following examples assume the following statements appear before",
  "the example expression:",
  "",
  "        function n_cubed(nn)",
  "            return nn * nn * nn",
  "        endfunction",
  "        set strABC=\"ABC\"",
  "        set str016=\"016\"",
  "        set strY=\"Y\"",
  "        set num12=12",
  "        set num3=3",
  "        set boolTrue=true",
  "",
  "    Example                          Result   Description",
  "",
  "     1. n_cubed(2) - n_cubed(1)           7   8 - 1 = 7",
  "",
  "     2. left(str016, 2)                 \"01\"   left(\"016\", 2) = \"01\"",
  "",
  "     3. left(str016 - 1, 2)             \"15\"   left(\"15\", 2) = \"15\"",
  "",
  "     4. strABC + 1                    *Error   \"ABC\" is not a number",
  "",
  "     5. strY or strABC + 1              true   True because strY is true",
  "",
  "     6. strABC & n_cubed(num3 - 1)     \"ABC8\"   \"ABC\" concatenated 2*2*2",
  "",
  "See also:           _expfunctions_, _parsing_, _substitution_, _variables_",
  "                    _userfunctions_",
  "                    _http://en.wikipedia.org/wiki/Order__of__operations_",
  "",
  "",
NULL
};

static char * chelp_text_intro[] = {
  "intro to desh",
  "",
  "Desh is a new shell and command language interpreter.  It has some",
  "features that are similar",
  "to other shells such as Unix based shells and the Windows command prompt.",
  "",
  "The goals of desh are:",
  "",
  "    1.    Provide a command language interpreter that behaves",
  "substantially the same on Unix and Windows.  Moving scripts between",
  "the platforms should require minimal translation.",
  "",
  "    2.    Scripts should stop processing when an unexpected error occurs.",
  "Shells scripts have a bad habit of continuing even when a serious error has",
  "occurred.  This causes many subsequent errors and undesirable results.",
  "Desh attempts to help this problem by stopping on an error.",
  "Errors within a script can be caught using try-throw-catch.",
  "",
  "    3.    Shell scripts tend to have too many special characters and",
  "unreadable parsing.  Desh attempts to help this problem in several",
  "ways:",
  "",
  "            i.    Like other shells, file names containing special characters",
  "must be enclosed in quotes.  However, in desh, this only needs to be done",
  "once.  For example, this script works in desh:",
  "",
  "                      set SRC_FILE= \"Source File\"",
  "                      set TGT_FILE= \"Target File\"",
  "                      copy $SRC_FILE $TGT_FILE",
  "",
  "                  This script works in desh because commands are parsed first,",
  "then variable substitution is done.  Not the other way around.  In other shells,",
  "the copy command would be interpreted as:",
  "",
  "                      copy Source File Target File",
  "",
  "                  This would not be what you want.",
  "",
  "            ii.   There are no confusing escape characters.  When an escape",
  "character would be needed to distinguish a special character, the",
  "special character is repeated instead of using as escape.  For example,",
  "the Unix command:",
  "",
  "                      echo The amount is \\$2.16",
  "",
  "                  is accomplished in desh with:",
  "",
  "                      echo The amount is $$2.16",
  "",
  "                  To put a quotation mark in a quote, simply repeat the",
  "quotation mark.  Example:",
  "",
  "                    echo He said \"\"\"Don't do that!\"\"\"",
  "",
  "                        results in output:",
  "",
  "                    He said \"Don't do that!\"",
  "",
  "                         In this example, the very first quote in the",
  "echo command begins a quoted argument.  The second quote is doubled",
  "to put a quote within the argument.  The last three quotes are a doubled",
  "quote and then a final quote to terminate the argument.",
  "",
  "    4.    Subject to the other goals, desh scripts should be relatively",
  "easy to port from other shell scripts and easy to read.  For example,",
  "if the user is familiar with Unix Bourne scripts, a desh script should",
  "be easy to understand without knowing the particulars.",
  "",
  "See also:       _parsing_, _scripting_, _shells_",
  "",
  "",
  "",
NULL
};

static char * chelp_text_keyboard[] = {
  "keyboard input",
  "",
  "Since desh is a shell as well as a scripting tool, input is typically",
  "done from the keyboard.",
  "",
  "Command Prompt",
  "",
  "    The command prompt is controlled by the variable DESHPROMPT1.  The default",
  "value of DESHPROMPT1 is \"$ \", but is easily changed with the set command.  Before",
  "the prompt is displayed, it is evaluated for substitutions the way a command is",
  "evaluated before execution.  Changes to the prompt are often put in the the",
  "file desh.ini (see _desh_) so that they are always executed when desh starts.",
  "For example, if you wished to have the time and your current directory",
  "in your command prompt, your desh.ini file may contain the command:",
  "",
  "        set DESHPROMPT1='${now(\"%H:%M\")} $PWD > '",
  "",
  "Command Line Continuation",
  "",
  "    Commands are executed immediately when the Enter key is pressed.  To",
  "continue a command to the next line, the line must be terminated with a circumflex",
  "or hat (^).  Continued lines prompted using the variable DESHPROMPT2, which",
  "has a default of \"> \".",
  "",
  "Comments",
  "",
  "    The pound sign (#) in a command begins a comment.  Unless it is in a",
  "quotation, the pound sign begins a comment and all characters after it are",
  "ignored.",
  "",
  "Special Keys",
  "",
  "    Printing keys like a, b, 0, 1 and $ are all considered part of the command.",
  "Other keys have a special meaning and are handled immediately by desh.  The",
  "special keys are:",
  "",
  "    Enter/Return        The Enter key (sometimes labelled return) ends the",
  "line and executes the command unless it has been continued with a ^.",
  "",
  "    Up arrow            Displays the previous command for execution or",
  "editing.  Press up arrow again go back further, edit the command, or",
  "press Enter to execute the command.",
  "",
  "    Down arrow          Displays the next command for execution or",
  "editing.  Only works if up arrow has already been pressed.",
  "",
  "    Left arrow          Moves the cursor one character to the left.",
  "",
  "    Right arrow         Moves the cursor one character to the right.",
  "",
  "    Home                Moves the cursor to the beginning of line.",
  "",
  "    End                 Moves the cursor one character to the end of line.",
  "",
  "    Left delete         (Backspace) Deletes the character to the left",
  "of the cursor and moves the cursor one character to the left.",
  "",
  "    Right delete        (Delete) Deletes the character to the right",
  "of the cursor.",
NULL
};

static char * chelp_text_parsing[] = {
  "command parsing",
  "",
  "Command parsing in desh is a bit unusual in that commands are parsed",
  "in one of two ways, depending on the command.  Commands that have an expression",
  "in them like if and while use \"expression parsing.\"  Other commands use",
  "\"parameter parsing.\"  This dual parsing allow a much more natural",
  "expression syntax without sacrificing the simplicity of regular commands.",
  "The help text for each built-in command indicates which type of parsing is used.",
  "",
  "Parameter parsing",
  "",
  "    External commands, and built-in commands like copy are parsed using",
  "parameter parsing.  Parameter parsing uses spaces as delimiters and",
  "supports input/output redirection.  With parameter parsing, command",
  "arguments are often file names.",
  "",
  "    Between arguments, two or more spaces are treated as one space.",
  "To put special characters or spaces in a single argument, surround the",
  "argument with single or double quotes.",
  "",
  "Expression parsing",
  "",
  "    Built-in commands with an expression (like while) are parsed using",
  "expression parsing.  Expression parsing treats operators like",
  "< (less than) naturally and does not support input/output redirection.",
  "With expression parsing, command arguments are often variable names",
  "instead of file names.",
  "",
  "Examples:",
  "",
  "    The easiest way to understand the parsing is through an example.",
  "Look at the command:",
  "",
  "        type alpha > beta",
  "",
  "    This example uses the type command to display a file.  Since",
  "type is parsed with parameter parsing, the \"> beta\" means that",
  "the command output (the contents of alpha) is written to the file beta.",
  "Now look at the command:",
  "",
  "        while alpha > beta",
  "",
  "    This example looks very similar, but has a completely different meaning",
  "since while is parsed with expression parsing.  This command begins",
  "a while loop that continues as long as the variable alpha is greater",
  "than the variable beta.  The \"> beta\" is interpreted as greater than the",
  "variable beta.",
  "",
  "See also:       _scripting_, _shells_",
  "",
NULL
};

static char * chelp_text_redirection[] = {
  "input/output redirection in desh",
  "",
  "Built-in commands parsed with parameter parsing and external commands",
  "may have their input and output redirected using the somewhat standard",
  "redirection operators.  They are:",
  "",
  "    cmd >myfile             Writes stdout of cmd to the file named myfile.",
  "The contents of file myfile are erased before any output is written.",
  "",
  "    cmd >>myfile            Appends stdout of cmd to the file named myfile.",
  "The original contents of file myfile remain.",
  "",
  "    cmd 2>myfile            Writes stderr of cmd to the file named myfile.",
  "The contents of file myfile are erased before any output is written.",
  "",
  "    cmd 2>>myfile           Appends stderr of cmd to the file named myfile.",
  "The original contents of file myfile remain.",
  "",
  "    cmd >myfile 2>&1        Writes stdout of cmd to the file named myfile.",
  "The contents of file myfile are erased before any output is written.",
  "Writes stderr of cmd to stdout, which is myfile.",
  "",
  "    cmd <myfile             Reads stdin of cmd from the file named myfile.",
  "",
  "    cmd <<ENDOFDATA         Reads stdin of cmd from the current stdin.  The",
  "end of cmd's stdin is denoted by a line containing only ENDOFDATA (or",
  "whatever follows the <<.  If there are lines using $ substitution between",
  "cmd and ENDOFDATA, they are substituted using current variable values.  To",
  "inhibit an instance of substitution, use two dollar signs, e.g. $$MYVAR.",
  "See: _http://en.wikipedia.org/wiki/Here__document_",
  "",
  "    cmd <<<ENDOFDATA        Same as <<, except that no substitution is done",
  "and each line is passed as is to cmd's stdin.",
  "",
  "    cmd1 | cmd2             The stdout of cmd1 is \"piped\" to the stdin of cmd2.",
  "If the first command is a user function call or a built-in command, then the",
  "command is run is the desh process.  Since desh is single-threaded, only the",
  "first piped command may be a user function call or a built-in command.",
  "See _http://en.wikipedia.org/wiki/Pipeline__(Unix)_",
  "",
  "Commands without redirection",
  "",
  "    Input/output redirection on built-in commands parsed with expression",
  "parsing is not done.  Examples of commands with no redirection are if",
  "and while.  By not supporting redirection on expression parsed commands,",
  "< may be used for less-than and > may be used for greater-than.",
  "",
  "See also:       _parsing_, _substitution_",
  "",
  "",
NULL
};

static char * chelp_text_scripting[] = {
  "Scripting in desh",
  "",
  "In desh, scripts are made by entering desh commands into a text file.",
  "Once the script is in a text  file, it may be called from within desh",
  "or from another shell.",
  "",
  "Running scripts within desh",
  "",
  "    Scripts may be run within desh with either the call command or",
  "the dot (.) command.  The call command is used when you wish to",
  "have the script perform a task and then return with to the state",
  "before calling.  Current function definitions and variables",
  "are not changed by the called script.  The dot (.) command",
  "also calls a script, but behaves the similarly to when commands",
  "are entered from the keyboard; variables and function definitions",
  "are changed.  The dot (.) command is good to initialize variables or for",
  "a function library.",
  "",
  "Case Sensitivity",
  "",
  "    Case sensitivity is tricky in desh because desh is designed to",
  "behave substantially the same in both Windows and Unix environments,",
  "but Windows is mostly case insensitive while Unix is mostly",
  "case sensitive.  The desh shell option -i is used to control",
  "case sensitivity. When -i is set (the default on Windows),",
  "command names, function names and variable names are all",
  "case insensitive.  When -i is not set (the default on Unix),",
  "command names, function names and variable names are all",
  "case sensitive and must match exactly.  Built-in command options",
  "(e.g. -y for copy) are case insensitive regardless of the -i",
  "option.  The -i may be set when desh is run or with the",
  "_shopt_ command.",
  "",
  "    Options case insensitive",
  "    Commands/variables depend on shopt -i",
  "",
  "Special Characters",
  "",
  "    The following characters are special no matter which kind of parsing is used:",
  "",
  "        #           Begins a comment to end of line.",
  "",
  "        ;           Command separator used to separate commands on same line.",
  "",
  "        ^           If used at the end of a line, continues command to next line.",
  "Also used to indicate fileset substitution on Windows. e.g. ^*.txt puts a",
  "list of text files from the currents directory into the command line. Use",
  "^^ for a single ^ with no special meaning.",
  "",
  "        $var        Substitutes the value of var into the command line.",
  "",
  "        $$var       Is interpreted as $var.  No substitution is done.",
  "",
  "        $^<var>     Substitutes with the value of <var> and then",
  "reparses tokens.  This is how other shells typically substitute.",
  "",
  "        ${exp}      Substitutes the result of the expression exp into",
  "the command line.  The expression is parsed with expression parsing.",
  "",
  "        \"arg\"       Use double-quotes to include spaces and other special",
  "characters in a single argument, with substitution.  Inside double-quotes,",
  "use two double-quotes to be interpreted as one double-quote",
  "Inside double-quotes, use $var to substitute the value of var.",
  "",
  "        'arg'       Use single-quotes to include spaces and other special",
  "characters in a single argument, without substitution.  Inside",
  "single-quotes, use two single-quotes to be interpreted as one",
  "single-quote. Inside single-quotes, no substitution is done and",
  "$var is interpreted as is.",
  "",
  "        `cmd`       Executes cmd, then substitutes the output",
  "into the command line.",
  "",
  "See also:       _parsing_, _substitution_",
NULL
};

static char * chelp_text_shells[] = {
  "shells comparison",
  "",
  "The following compares desh with the Windows command (.bat) processor and the",
  "Unix Bourne shell.",
  "",
  "Substitution",
  "",
  "    Desh              Bourne shell      Windows           Description",
  "",
  "    $ARGC             $#                n/a               No. of command args",
  "",
  "    $0                $0                %0                Command to run shell",
  "",
  "    $1, $2, ...       $1, $2, ...       %1, %2, ...       Command arg 1, 2, ...",
  "",
  "    $*                $*                %*                All arguments",
  "",
  "    $?                $?                ERRORLEVEL        Return value from",
  "                                                          most recent command.",
  "",
  "    $varname          $varname          %varname%         Value of varname",
  "",
  "    ${exp}            `expr 'exp'`      n/a               Value of expression",
  "",
  "Quoting",
  "",
  "    Desh              Bourne shell      Windows           Description",
  "",
  "    \"                 \"                 \"                 Double-quotes permit",
  "                                                          substitution within",
  "                                                          quoted string.",
  "",
  "    '                 '                 n/a               Single-quotes",
  "                                                          disable substitution",
  "                                                          within quoted string.",
  "",
  "    `                 `                 n/a               Back-quotes",
  "                                                          substitute command",
  "                                                          result for quoted string.",
  "",
  "I/O Redirection and Piping",
  "",
  "    Desh              Bourne shell      Windows           Description",
  "",
  "    cmd >filename     cmd >filename     cmd >filename     Write stdout of cmd",
  "                                                          to filename.",
  "",
  "    cmd >>filename    cmd >>filename    cmd >>filename    Append stdout of cmd",
  "                                                          to filename.",
  "",
  "    cmd <filename     cmd <filename     cmd <filename     Read stdin of cmd",
  "                                                          from filename.",
  "",
  "    cmd 2>filename    cmd 2>filename    cmd 2>filename    Write stderr of cmd",
  "                                                          to filename.",
  "",
  "    cmd 2>&1          cmd 2>&1          cmd 2>&1          Write stderr of cmd",
  "                                                          to stdout.",
  "",
  "    cmd1 | cmd2       cmd1 | cmd2       cmd1 | cmd2       Pipe stdout of cmd1",
  "                                                          to stdin of cmd2.",
  "",
  "Common commands",
  "",
  "    Desh              Bourne shell      Windows           Description",
  "",
  "    #                 #                 REM               Comment line.",
  "",
  "    ;                 ;                                   Command separator",
  "",
  "    copy              cp                COPY              Copy file.",
  "",
  "    cd                cd                CD                Change current",
  "                                                          directory.",
  "",
  "    dir               ls                DIR               List files in",
  "                                                          directory.",
  "",
  "    echo              echo              ECHO              Display text.",
  "",
  "    exit              exit              EXIT/B            Exit script/shell.",
  "",
  "    for / while       for               FOR               Loop through items.",
  "",
  "    move              mv                MOVE              Move/rename file.",
  "",
  "    remove            rm                DEL               Remove file.",
  "",
  "    removedir         rm -R             RMDIR/S           Remove directory and",
  "                                                          files in directory.",
  "",
  "    set a=b           a=b               SET a=b           Sets variable a to",
  "                                                          value b.",
  "",
  "    type              cat               TYPE              Display text file.",
  "",
  "See also:       _parsing_, _substitution_",
NULL
};

static char * chelp_text_substitution[] = {
  "substitution in command lines",
  "",
  "Command line substitute is common in many shells and scripting",
  "languages, however it is done a bit differently in desh.  To substitute",
  "a simple variable, put a dollar sign ($) before the variable name.",
  "i.e. $MYVAR.  What makes desh substitution atypical is that",
  "substitution is done AFTER the command has been tokenized.  This",
  "means things like spaces in the variable value do not change",
  "the way the command is parsed.  For example, take these commands:",
  "",
  "    set FILE1=\"File One\"",
  "    set FILE2=\"File Two\"",
  "    copy $FILE1 $FILE2",
  "",
  "Typically the copy command would be interpreted as:",
  "",
  "    copy File One File Two",
  "",
  "Desh interprets the copy command the same as:",
  "",
  "    copy \"File One\" \"File Two\"",
  "",
  "This avoids the necessity of continually putting quotes",
  "around substitutions.",
  "",
  "Substitution in expressions",
  "",
  "    Substitution in expressions is generally to be discouraged because it is",
  "often unnecessary.  For example, if variable TEN has the value of 10, it is",
  "simpler to use 2 * TEN, rather than 2 * $TEN, although they both work.",
  "Substitution may also be done in a variable or function name, but the",
  "resulting substitution must be a valid token.  For example, these statements",
  "are perfectly good:",
  "",
  "    set ix=30 + 3",
  "    set list$ix=2   # Sets variable list33 to 2",
  "",
  "But these statements fail:",
  "",
  "    set ix=\"30 + 3\"",
  "    set list$ix=2   # Attempts to set variable \"list30 + 3\", which is an error",
  "",
  "Available Substitutions",
  "",
  "    $<varname>      Substitutes with the value of <varname> into the",
  "command.  e.g. $MYVAR is similar to Unix $MYVAR",
  "",
  "    $%xx            Substitutes character represented by hexadecimal xx,",
  "e.g. line feed is $%0A, return is $%0D.  e.g. $%09 is similar to Unix \\t",
  "",
  "    $/              Substitutes directory separator.  That is \"\\\" on Windows",
  "and \"/\" on others.  e.g. dnam$/fnam is similar to Unix dnam/fnam",
  "or dnam\\fnam on Windows.",
  "",
  "    $^<varname>     Substitutes with the value of <varname> and then",
  "reparses tokens.  This is how other shells typically substitute.",
  "",
  "    $$              Substitutes $.  This is used to suppress substitution.",
  "e.g. $$MYVAR results in $MYVAR.",
  "",
  "    $n              Substitutes argument n where is from 0 to 9.  Argument 0",
  "is the name of the program, script or function. e.g. $1 is similar to Unix $1.",
  "",
  "    $*              Substitutes all parameters.  This results in many parameters",
  "passed, not one.  The shift command can be used to remove arguments.",
  "e.g. $* is similar to Unix $*",
  "",
  "    $?              Substitutes last return code. e.g. $? is similar to Unix $?",
  "",
  "    ${<exp>}        Substitutes result of expression <exp>.",
  "e.g. ${2 * 3} substitutes 6.",
  "",
  "    `<command>`     Substitutes with output of <command>",
  "e.g. `echo @one two@` substitutes @one two@, similar to Unix.",
  "See: _http://en.wikipedia.org/wiki/Command__substitution_",
  "",
  "    ^<fileset>      Substitutes with files matching fileset. Wildcards for",
  "fileset are: * matches zero or more characters, ? matches any single character,",
  "[<char_list>] matches a single character against a list or range of characters.",
  "<char_list> examples:  [0-9] matches a digit, [0-9a-f] matches a hexadecimal digit, [aeiou]",
  "matches a vowel.  If the desh -f flag is set (the default on Unix), the leading",
  "circumflex (^) may be omitted, e.g. *.html substitutes all .html files if the",
  "-f is set.  Without -f (The default on Windows), ^*.html is necessary.",
  "",
  "",
  "Example 1:      set SRC_FILE=\"Src Dir$/Src File\"",
  "                set TGT_FILE=\"Tgt Dir$/Tgt File\"",
  "                copy $SRC_FILE $TGT_FILE",
  "",
  "                    This series of commands on Unix copies a file:",
  "",
  "                    On Unix:",
  "",
  "                        Src Dir/Src File --copy--> Tgt Dir/Tgt File",
  "",
  "                    On Windows",
  "",
  "                        Src Dir\\Src File    --copy--> Tgt Dir\\Tgt File",
  "",
  "Example 2:      copy MyFile MyFileBKUP${now(\"%y%m%d%H%M%S\")}",
  "",
  "                    This command copies MyFile to a backup file with a name",
  "in the format of MyFileBKUPyymmddhhmmss.",
  "",
  "See also:       _parsing_, _export_, _set_, _expressions_, _variables_",
  "",
  "",
NULL
};

static char * chelp_text_userfunctions[] = {
  "desh user defined functions",
  "",
  "Desh supports functions as in other programming languages.  In desh,",
  "function definitions are stored internally as text and then are",
  "interpreted when called.  Functions may or may not return a value",
  "to the caller.  To return a value, the return command is used.",
  "",
  "The function command is used to create a user function definition",
  "and contain any number of function arguments.  The syntax is:",
  "",
  "        function <func-name> [ ( <arg> [ , ... ] ) ]",
  "            [ <commands> ]",
  "        endfunction",
  "",
  "User functions are reentrant and may be called recursively.  Function",
  "arguments and variables are local to the function and are deleted when",
  "the function ends.  All arguments to a function are passed by value.",
  "If extra arguments are passed to the function, the first extra argument",
  "is accessed with $1 the second with $2, etc.  For example, the following",
  "two functions are equivalent:",
  "",
  "        function sum3(aa, bb, cc)",
  "            return aa + bb + cc",
  "        endfunction",
  "",
  "        function sum3",
  "            set aa=$1",
  "            set bb=$2",
  "            set cc=$3",
  "",
  "            return aa + bb + cc",
  "        endfunction",
  "",
  "This function is also equivalent:",
  "",
  "        function sum3",
  "            set aa=$1 ; shift",
  "            set bb=$1 ; shift",
  "            set cc=$1",
  "",
  "            return aa + bb + cc",
  "        endfunction",
  "",
  "Which makes these two function yet more equivalents:",
  "",
  "        function sum3(aa)                   function sum3(aa, bb)",
  "            set bb=$1 ; shift                   set cc=$1",
  "            set cc=$1                           return aa + bb + cc",
  "                                            endfunction",
  "            return aa + bb + cc",
  "        endfunction",
  "",
  "There is a slight difference in all these sum3 functions.  If arguments",
  "are present in function definition, then they are required when the",
  "function is called.  In the first example sum3, at least three arguments are",
  "required, but in the second example no arguments are required.",
  "",
  "Functions may be called as a command or as part of an expression.  When called",
  "as an expression, the calling expression must place the arguments in parentheses",
  "separated by commas.  When called as a command, the calling command places the",
  "arguments in the command line separated by spaces.  Also, when called as a command,",
  "all arguments are passed as literal strings.  To pass a variable value in",
  "a command, substitution using the dollar ($) sign must be used.  If a function",
  "that returns a value is called as a command, the return value is lost.  Here are some",
  "examples of calling sum3:",
  "",
  "        set var=sum3(3, 5, 7)               # Call set3 in an expression",
  "",
  "        echo Total is ${sum3(3, 5, 7)}      # Expression substitution",
  "",
  "        sum3 3 5 7                          # Call as command, loses result",
  "",
  "Here are more examples using a function called combo that calculates",
  "the number of combinations of k items from a set of n.  The number of",
  "combinations is defined as:",
  "",
  "                n!",
  "            -----------",
  "            k! (n - k)!",
  "",
  "Where ! is defined as the factorial function.  For more information, see:",
  "_http://en.wikipedia.org/wiki/Combination_",
  "",
  "Example 1:          function combo(nn, kk)",
  "                        return factorial(nn) / ^",
  "                              (factorial(nn - kk) * factorial(kk))",
  "                    endfunction",
  "",
  "                    function factorial(nn)",
  "                        set ff = 1",
  "                        for ii = 2 to nn",
  "                            set ff = ff * ii",
  "                        endfor",
  "                        return ff",
  "                    endfunction",
  "",
  "                    echo 8 things taken 3 at a time is ${combo(8,3)}",
  "",
  "                        This example has the combo function calling the factorial",
  "function to calculate the number of combinations. The",
  "display is:",
  "",
  "                    8 things taken 3 at a time is 56",
  "",
  "Example 2:          function combo(nn, kk)",
  "                        if kk = 0 or kk = nn ; return 1 ; endif",
  "",
  "                        return combo(nn - 1, kk) + combo(nn - 1, kk - 1)",
  "                    endfunction",
  "",
  "                    echo 7 things taken 3 at a time is ${combo(7,3)}",
  "",
  "                        This example uses a different, mathematically",
  "equivalent combo function that recursively calls itself. The display is:",
  "",
  "                    7 things taken 3 at a time is 35",
  "",
  "Example 3:          function show_pascal_line(num)",
  "                        set lbuf = \"\"",
  "                        for ii=0 to num",
  "                            set lbuf=lbuf & \" \" & combo(num, ii)",
  "                        endfor",
  "                        echo $lbuf",
  "                    endfunction",
  "",
  "                    function show_pascal(max)",
  "                        # See: http://en.wikipedia.org/wiki/Pascal's_triangle",
  "                        for ii=0 to max",
  "                            show_pascal_line $ii",
  "                        endfor",
  "                    endfunction",
  "",
  "                    show_pascal 6",
  "",
  "                        This example adds two more functions and uses one of",
  "the combo functions above to display a Pascal's triangle.",
  "The show_pascal function is called as a command, which then uses a",
  "command to call the show_pascal_line function.",
  "Note that the call to show_pascal_line uses \"$ii\" for an",
  "argument because the value of ii needs to substituted into",
  "the command line. If the command was \"show_pascal_line ii\",",
  "the num argument would be set to \"ii\" which is not a number.",
  "The display is:",
  "",
  "                     1",
  "                     1 1",
  "                     1 2 1",
  "                     1 3 3 1",
  "                     1 4 6 4 1",
  "                     1 5 10 10 5 1",
  "                     1 6 15 20 15 6 1",
  "",
  "Example 4:          function get_time",
  "                        return now(\"%I:%M %p\")",
  "                    endfunction",
  "",
  "                    set the_time=get_time()",
  "                    echo The time is $the_time",
  "",
  "                        This example shows how to call a function that",
  "returns a value, but has no parameters.  The function get_time is called",
  "with an empty argument list \"()\" to distinguish a function call",
  "from a variable name.",
  "",
  "See also:           _function_, _parsing_, _substitution_, _variables_",
  "",
NULL
};

static char * chelp_text_variables[] = {
  "variables in desh",
  "",
  "Variables are necessary in just about every scripting and",
  "programming language. In desh, the set command is used to set",
  "the value of a variable.  Expressions and command line",
  "subsitution access variables.",
  "",
  "Variable Scope",
  "",
  "    In desh there are four different variable scopes:",
  "",
  "        1. function",
  "        2. script",
  "        3. global (environment variables)",
  "        4. built-in",
  "",
  "    When a variable is accessed in an expression, the variable is",
  "searched for in the order listed.  If the variable access",
  "is within a user defined function, the function scope is searched",
  "first.  If not within a user defined function, the script scope",
  "is searched first.",
  "",
  "    When a variable is set with the set command, it is set at the",
  "same scope in which it was defined (it is overwritten).",
  "If the variable has not been",
  "defined, it is automatically defined at the function scope",
  "if within a user defined function, or at the script level if not",
  "within a user defined function.",
  "",
  "Scopes",
  "",
  "    1. function",
  "",
  "        Arguments to user defined functions and variables first set",
  "within the function have a function scope.  Variables with a function scope",
  "are only accessible within the function.",
  "",
  "    2. script",
  "",
  "        If a variable is first set outside of a user defined function,",
  "it is defined at the script scope.  This means all remaining commands",
  "within the script may access the variable.  However, if the call command",
  "is used run another script, a new script scope is created and variables",
  "in the calling script are not accessible to the called script.",
  "",
  "    3. global (environment variables)",
  "",
  "        Environment variables are defined as global variables when",
  "desh is started, and desh passes them on when a program is started with desh.",
  "The desh export command is used to convert a function or script",
  "variable to a gloabal/environment variable.",
  "",
  "    4. built-in",
  "",
  "        Built-in variables are searched if the variable is not defined at a higher",
  "scope.  Built-in variables are internal to desh and are:",
  "",
  "        ARGC        Number of arguments used to the call script or function.",
  "",
  "        DESHVERSION     The version",
  "",
  "        ERRCMD      In a catch, the command that caused the error.",
  "",
  "        ERRMSG      In catch, the error message from the command that caused error.",
  "",
  "        ERRNUM      In catch, desh error number of command that caused error",
  "",
  "        HOME        Home directory of user.  On Windows systems, this is the same",
  "value as the environment variable USERPROFILE.",
  "",
  "        PID         The operating system process ID of the desh process.",
  "",
  "        PWD         Current working directory.",
  "",
  "Variable Data Types",
  "",
  "    The data type of variables is automatically assigned by desh and the",
  "user does not typically need to be concerned about the data type",
  "of variables.  The data types internal to desh are string, integer and",
  "boolean.  However, expression functions and operators often require data",
  "of a specific type.  For example, the multiplication operator (*)",
  "requires integer operands to multiply.  Automatic conversions are",
  "done as follows:",
  "",
  "    Boolean to Integer      FALSE is converted to 0 and TRUE is",
  "converted to 1.",
  "",
  "    Boolean to String       FALSE is converted to \"true\" and TRUE is",
  "converted to \"true\".",
  "",
  "    Integer to Boolean      If the integer is 0, it is converted to",
  "FALSE, otherwise it is converted to TRUE.",
  "",
  "    Integer to String       Integers are converted to strings with an optional",
  "leading negative sign and without leading zeros.",
  "",
  "    String to Boolean       Strings are converted to boolean using a",
  "case insensitive comparison with specific values.",
  "",
  "                            These strings are converted to FALSE:",
  "                                FALSE, F, NO, N",
  "",
  "                            These strings are converted to TRUE:",
  "                                TRUE, T, YES, Y",
  "",
  "                            Strings that contain a valid integer (see below)",
  "                            are converted using Integer to Boolean.",
  "                            All other strings generate an error.",
  "",
  "    String to Integer       Integers are converted to strings with leading",
  "and trailing spaces ignored.  An optional leading sign is permitted and",
  "all characters of the number must be digits. i.e. Decimal points,",
  "dollar signs and commas are not permitted. Integers are stored as",
  "64-bit integers and must be from -9223372036854775808 through 9223372036854775807.",
  "An illegal conversion generates an error.",
  "",
  "Variable Names",
  "",
  "    Variable names must begin with an alphabetic character or underscore (_).",
  "After the first character, variable names must contain only alphanumeric",
  "characters or underscores.",
  "",
  "    When desh is started, all existing environment variables become global",
  "variables.  If global variables have non-alphanumeric characters other",
  "than underscore, those characters are changed to an underscore.  For",
  "example, the variable \"ProgramFiles(x86)\" becomes \"PROGRAMFILES_X86_\" in",
  "desh on Windows.",
  "",
  "Variables automatically set by desh",
  "",
  "        DESHSTARTPID    The start command automatically sets this to the",
  "process identification number (pid) to the start process.",
  "",
  "        ERRCMD          When a command error occurs, set to the command",
  "that caused the error.",
  "",
  "        ERRMSG          When a command error occurs, set to the the error",
  "message.",
  "",
  "        ERRNUM          When a command error occurs, set to the desh error",
  "number.",
  "",
  "        PWD             The cd command automatically sets this to the",
  "new current directory.",
  "",
  "Examples",
  "",
  "Example 1:      function myfunc(MYVAR)",
  "                    echo $MYVAR",
  "                endfunction",
  "",
  "                set MYVAR=\"MYVAR in script\"",
  "                echo $MYVAR",
  "                myfunc \"MYVAR in myfunc\"",
  "                echo $MYVAR",
  "",
  "                    This series of commands demonstrates the use of the variable",
  "MYVAR in both the function and script scopes.  The output is:",
  "",
  "                        MYVAR in script",
  "                        MYVAR in myfunc",
  "                        MYVAR in script",
  "",
  "Example 2:      set STRVAR1=\"This is STRVAR1\"",
  "                set STRVAR2=\"    00002      \"",
  "                set NUMVAR1=STRVAR2 + 1",
  "                set BOOLVAR=(2 > 1)",
  "",
  "                echo STRVAR1=$STRVAR1",
  "                echo NUMVAR1=$NUMVAR1",
  "                echo BOOLVAR=$BOOLVAR",
  "                echo This time my pid is $PID",
  "",
  "                    This series of commands demonstrates the automatic data",
  "type conversions done by desh.  The output is:",
  "",
  "                        STRVAR1=This is STRVAR1",
  "                        NUMVAR1=3",
  "                        BOOLVAR=TRUE",
  "                        This time my pid is 2812",
  "",
  "See also:       _parsing_, _export_, _set_, _expressions_, _substitution_",
  "_http://en.wikipedia.org/wiki/Environment__variable_",
  "",
  "",
  "",
NULL
};

static char * chelp_text_call[] = {
  "call command",
  "",
  "The call command executes a desh script using a new scope.",
  "",
  "Syntax:             call <script-file> [ <arg> ...]",
  "",
  "    <script-file>   The name of the file containing the desh script.",
  "This must be the name of an existing script file.  No path is",
  "searched.",
  "",
  "    <arg>           Argument to the script.  The called script",
  "accesses the first argument as $1, the second as $2, etc.",
  "",
  "Notes:              The call command creates a new scope for script",
  "variables and functions.  Non-exported variables in the current",
  "scope are not accessible in the called scope and all script",
  "variables created in the called script are deleted when it completes.",
  "",
  "                    The dot (.) command is the same as call, except",
  "that the current scope is used and a new scope is not created.",
  "",
  "Parsing:            Parameter",
  "",
  "Similar to:         Windows CALL command, Unix sh command",
  "",
  "Example:            call my_script.txt file1 file2",
  "",
  "                        Executes script file my_script.txt in a new",
  "scope passing file1 as $1 and file2 as $2.",
  "",
  "See also:           _dot_, _parsing_, _scripting_, _variables_",
  "",
NULL
};

static char * chelp_text_catch[] = {
  "catch command",
  "",
  "The catch command is used to catch errors within a try block.  Each",
  "catch block may contain one catch command.  If any of the commands",
  "before the catch command fails, commands are skipped until",
  "the catch command. If none of the commands before the catch command fail,",
  "then commands after catch commands are skipped until the endtry.",
  "",
  "Syntax:         catch",
  "",
  "Parsing:        Expression",
  "",
  "Similar to:     Windows n/a command, Unix n/a command",
  "",
  "Example 1:      try",
  "                    copy aaa xxx",
  "                    copy bbb yyy",
  "                catch",
  "                    echo A COPY statement failed with error number $ERRNUM",
  "                    echo The error message is: $ERRMSG",
  "                endtry",
  "",
  "                    This series of commands copies files aaa and bbb.  If",
  "an error occurs during copying, the catch commands are executed which",
  "display an error message.  If all copy commands are successful, the",
  "catch commands are skipped.",
  "",
  "Example 2:      try",
  "                    try",
  "                        remove xxx",
  "                        remove yyy",
  "                    catch",
  "                        echo Not all files removed.",
  "                    endtry",
  "                    copy aaa xxx",
  "                    copy bbb yyy",
  "                catch",
  "                    echo A COPY statement failed with error number $ERRNUM",
  "                    throw ERRMSG",
  "                endtry",
  "",
  "                    If any of the remove commands fails, the remaining removes",
  "are skipped until the catch, which displays a message using echo.",
  "Whether or not the removes succeed, copying",
  "begins. If an error occurs during copying aaa or bbb, an error message is",
  "displayed using echo and another error is caused by the throw command.",
  "",
  "See also:       _errors_, _throw_, _try_",
  "",
NULL
};

static char * chelp_text_cd[] = {
  "cd command",
  "",
  "The cd command changes the current working directory.",
  "",
  "Syntax:         cd [-v] [ <directory> ]",
  "",
  "Notes:          If no directory is specified, the directory",
  "is changed to the user's home directory.  On Windows systems,",
  "the home directory is indicated by the USERPROFILE global variable.",
  "On other systems, the home directory is indicated by the HOME",
  "global variable and if HOME does not exist, the home directory is",
  "obtained from /etc/passwd.",
  "",
  "                The name of the current working directory can be",
  "accessed with the PWD global variable.  Example:",
  "",
  "                    echo The the current working directory is $PWD",
  "",
  "Options: -v     Verbose.  Shows the name of the new directory.",
  "",
  "Parsing:        Parameter",
  "",
  "Similar to:     Windows CD (CHDIR) command, Unix cd command",
  "",
  "Example:        cd \"C:\\Documents and Settings\\Admin\"",
  "",
  "                    Changes the current working directory to:",
  "",
  "                        C:\\Documents and Settings\\Admin",
  "",
  "                    The quotes are necessary because there are spaces",
  "                    in the full directory name.",
  "",
  "See also:       _parsing_",
  "",
NULL
};

static char * chelp_text_chmod[] = {
  "chmod command",
  "",
  "The chmod command changes the permission setting of files.",
  "The permission setting controls access to the file",
  "",
  "Syntax:         chmod <mode> <file> [...]",
  "",
  "    <mode>      The new access mode for the file.  Mode must",
  "be either <mode-flags> or <octal-mode>",
  "",
  "                    If <mode-flags> is used, a list of one or more",
  "of these flags is required:",
  "",
  "                        -r      Remove read access",
  "                        +r      Add read access",
  "                        -w      Remove write access",
  "                        +w      Add write access",
  "                        -x      Remove execute access (ignored)",
  "                        +x      Add execute access (ignored)",
  "",
  "                    If <octal-mode> is used, three octal digits are",
  "used to indicate, system, group (ignored) and owner access, in that",
  "order.  Each of the three octal digits is as follows:",
  "",
  "                        0       No access",
  "                        1       Execute access",
  "                        2       Write access",
  "                        3       Write and execute access (2+1)",
  "                        4       Read access",
  "                        5       Read and execute access (4+1)",
  "                        6       Read and write access (4+2)",
  "                        7       Read, write and execute access (4+2+1)",
  "",
  "    <file>      The file name of an existing file for which",
  "the permissions are to be changed.",
  "",
  "Notes:          WINDOWS ONLY.  This command is only available as",
  "a built-in command on Windows versions of desh.  On Unix versions,",
  "the chmod command already exists as an external command.",
  "",
  "                Above, ignored means the permission is ignored by",
  "Windows systems, but is available for syntax compatibility with",
  "Unix systems.",
  "",
  "Parsing:        Parameter",
  "",
  "Similar to:     Windows ATTRIB command, Unix chmod command",
  "",
  "Examples:       chmod -w MyFile.txt.",
  "",
  "                    Removes write access to MyFile.txt",
  "",
  "                chmod 444 file1.txt file2.txt",
  "",
  "                    Sets access to read-only for file1.txt and file2.txt",
  "",
  "See also:       _parsing_",
  "",
NULL
};

static char * chelp_text_copy[] = {
  "copy command",
  "",
  "The copy command copies a file to a new file or copies one or more files",
  "to a directory.",
  "",
  "Syntax:         copy [-v] [-y] <file> [ ...] <target>",
  "",
  "    <file>      The file to be copied.",
  "",
  "    <target>    Either a file name or an existing directory name.  To",
  "copy a file to the current working directory, use . for the <target>",
  "",
  "Options: -v     Verbose.  Shows the source and target files after each",
  "file is copied.",
  "",
  "         -y     Yes.  Specifies that if the target file already exits,",
  "it is to be overwritten.  It is an error if -y is not specified and",
  "the target file already exists.",
  "",
  "Parsing:        Parameter",
  "",
  "Similar to:     Windows COPY command, Unix cp command",
  "",
  "Examples:       copy ..\\MyFile.txt .",
  "",
  "                    Copies MyFile.txt from the parent directory to the current",
  "working directory.",
  "",
  "                copy -y file1.txt file2.txt file3.txt MyDir",
  "",
  "                    Copies file1.txt, file2.txt",
  "and file3.txt to the directory MyDir.  If any of the files already exist",
  "in MyDir, they will be overwritten.",
  "",
  "See also:       _errors_",
  "",
NULL
};

static char * chelp_text_dir[] = {
  "dir command",
  "",
  "The dir command lists files in a directory.  The dir command is very similar",
  "to the Windows DIR command.",
  "",
  "Syntax:             dir [ -<opt> [...] ] [ <fileset> [ ...] ]",
  "",
  "    <opt>           A dir option described below.",
  "",
  "    <fileset>       Shows files matching fileset.  If <fileset> is",
  "omitted, all files in the current directory are displayed.",
  "Wildcards may be used in <fileset> and are:",
  "",
  "                        * matches zero or more characters",
  "                        ? matches any single character",
  "                        [<char_list>] matches a single character against",
  "a list or range of characters.  Examples:",
  "",
  "                            [0-9] matches a digit",
  "                            [0-9a-f] matches a hexadecimal digit",
  "                            [aeiou] matches a vowel.",
  "",
  "Options:    -b      Bare.  Show only the file name.",
  "",
  "            -d      Descending.  Sort items in using a descending sort.",
  "",
  "            -g      Group.  Sort items in using a descending sort.",
  "",
  "            -r      Recursive.  Sort items in using a descending sort.",
  "",
  "            -s      Same as -r, recursive.",
  "",
  "            -t      Time.  Sort files in modification date and time order.",
  "",
  "            -x      UniX.  Show files in format similar to Unix long style.",
  "",
  "            -z      SiZe.  Sort files in order of size.",
  "",
  "Parsing:            Parameter",
  "",
  "Similar to:         Windows DIR command, Unix ls command",
  "",
  "Examples:       dir -b",
  "",
  "                    Shows all files and directories in the current directory,",
  "showing only the file name.  The files are sorted by name.",
  "",
  "                dir -x -t *.txt",
  "",
  "                    Shows all files in the current directory ending in \".txt\"",
  ", using Unix \"ls -l\" format.  The files are sorted by last modification date.",
  "",
  "                dir -r ..$/*.htm",
  "",
  "                    Shows all files in the parent of the current directory",
  "and subdirectories ending in \".htm\".  $/ is used to ensure that the",
  "command works correctly on Windows and Unix.",
  "",
  "See also:       _parsing_",
NULL
};

static char * chelp_text_dot[] = {
  "dot (.) command",
  "",
  "The dot (.) command executes a desh script using the current scope.",
  "",
  "Syntax:             . <script-file> [ <arg> ...]",
  "",
  "    <script-file>   The name of the file containing the desh script.",
  "This must be the name of an existing script file.  No path is",
  "searched.",
  "",
  "    <arg>           Argument to the script.  The script",
  "accesses the first argument as $1, the second as $2, etc.",
  "",
  "Notes:              The dot (.) command uses the current scope for script",
  "variables and functions.  This means that dot (.) can be used to",
  "define functions and variables to be used later in the calling script.",
  "",
  "                    The call command is similar to dot (.), except",
  "that call creates a new scope for variables and functions.",
  "",
  "Parsing:            Parameter",
  "",
  "Similar to:         Windows CALL command, Unix . command",
  "",
  "Example:            . my_script.txt file1 file2",
  "",
  "                        Executes script file my_script.txt in",
  "the current scope passing file1 as $1 and file2 as $2.",
  "",
  "See also:           _call_, _parsing_, _variables_",
  "",
NULL
};

static char * chelp_text_echo[] = {
  "echo command",
  "",
  "The echo command displays to stdout.",
  "",
  "Syntax:         echo [ <parm> ] [ ...]",
  "",
  "    <parm>      The text to be displayed.",
  "",
  "Notes:          The echo command parses each",
  "parameter and then displays each one separated by a space.  If",
  "parameters are separated by more than one space, only one",
  "space is displayed. To display several consecutive spaces, the",
  "parameter must be enclosed in quotes.  For example, to display",
  "\"Hello    World\", use",
  "",
  "                    echo \"Hello    World\"",
  "",
  "Parsing:        Parameter",
  "",
  "Similar to:     Windows ECHO command, Unix echo command",
  "",
  "Example 1:      echo Hello world.",
  "",
  "                    Displays \"Hello world.\" to stdout.",
  "",
  "Example 2:      echo",
  "",
  "                    Displays a blank line to stdout.",
  "",
  "Example 3:      echo Item,Desc  >OUTFIL",
  "",
  "                    Writes \"Item,Desc\" to OUTFIL.",
  "",
  "See also:       _parsing_",
  "",
NULL
};

static char * chelp_text_else[] = {
  "else command",
  "",
  "The else command is to provide an alternate path to a false if command.",
  "The else command may have another if to provide multiple paths to an if.",
  "",
  "Syntax:         else [ if <expression> ]",
  "",
  "Notes:          Any number of else if <expression> commands may",
  "appear after an if command, but only one else without an if.",
  "",
  "Parsing:        Expression",
  "",
  "Similar to:     Windows ELSE, Unix else and elif commands",
  "",
  "Example:        if num = 1",
  "                    call do_one",
  "                else if num = 2",
  "                    call do_two",
  "                else if num = 3",
  "                    call do_three",
  "                else if num = 4",
  "                    call do_four",
  "                else",
  "                    echo $num is invalid.  Expected 1,2,3 or 4.",
  "                endif",
  "",
  "",
  "                    This series of commands, calls either do_one, do_two,",
  "do_three or do_four, depending on the value of the variable num.",
  "",
  "See also:       _endif_, _expressions_,  _if_, _parsing_",
  "",
  "",
NULL
};

static char * chelp_text_endfor[] = {
  "endfor command",
  "",
  "The endfor command is used to terminate a for loop.  Each",
  "for command must be terminated be a corresponding endfor command.",
  "",
  "Syntax:         endfor",
  "",
  "Parsing:        Expression",
  "",
  "Similar to:     Windows n/a, Unix done (terminates for) command",
  "",
  "Examples:       for n = 0 to 4",
  "                    set f = 1",
  "                    for m = 2 to n",
  "                        set f = f * m",
  "                    endfor",
  "                    echo $n factorial is $f",
  "                endfor",
  "",
  "",
  "                    This series of commands displays:",
  "",
  "                    0 factorial is 1",
  "                    1 factorial is 1",
  "                    2 factorial is 2",
  "                    3 factorial is 6",
  "                    4 factorial is 24",
  "",
  "See also: _for_",
  "",
  "",
NULL
};

static char * chelp_text_endfunction[] = {
  "endfunction command",
  "",
  "The endfunction command is used to terminate a function definition.  Each",
  "function definition must be terminated be a corresponding endfunction.",
  "",
  "Syntax:         endfunction",
  "",
  "Parsing:        Expression",
  "",
  "Similar to:     Windows n/a, Unix } in { }",
  "",
  "Examples:       function is_prime(num)",
  "                    set is_it = false",
  "                    if num = 2",
  "                        set is_it = true",
  "                    else if num > 2 and num % 2 = 1",
  "                        set dd = 3",
  "                        set is_it = true",
  "                        while is_it and num / dd >= dd",
  "                            if num % dd = 0",
  "                                set is_it = false",
  "                            else",
  "                                set dd = dd + 2",
  "                            endif",
  "                        endwhile",
  "                    endif",
  "                    return is_it",
  "                endfunction",
  "",
  "                function show_primes(max)",
  "                    for ii = 1 to max",
  "                        if is_prime(ii)",
  "                            echo $ii is prime.",
  "                        endif",
  "                    endfor",
  "                endfunction",
  "",
  "                show_primes 20",
  "",
  "",
  "                    This series of commands shows a list a prime",
  "numbers with two functions: is_prime and show_primes.  The show_primes",
  "function loops through each number from 1 to the maximum and",
  "uses is_prime to check if is prime.  The commands display:",
  "",
  "                2 is prime.",
  "                3 is prime.",
  "                5 is prime.",
  "                7 is prime.",
  "                11 is prime.",
  "                13 is prime.",
  "                17 is prime.",
  "                19 is prime.",
  "",
  "See also: _function_, _userfunctions_",
  "",
  "",
NULL
};

static char * chelp_text_endif[] = {
  "endif command",
  "",
  "The endif command is used to terminate an if block.  Each",
  "if command must be terminated be a corresponding endif command.",
  "",
  "Syntax:         endif",
  "",
  "Parsing:        Expression",
  "",
  "Similar to:     Windows n/a, Unix fi command",
  "",
  "Examples:       if code1 = 0",
  "                    if code2 = 0",
  "                        call do_00",
  "                    else",
  "                        call do_01",
  "                    endif",
  "                else",
  "                    if code2 = 0",
  "                        call do_10",
  "                    else",
  "                        call do_11",
  "                    endif",
  "                endif",
  "",
  "                    This series of commands, calls either do_00,",
  "do_01, do_10 or do_11, depending on the value of the variables",
  "code1 and code2.",
  "",
  "                if docop = 1 or  docop = 3; copy src tgt; endif",
  "",
  "                    If the value of the variable docop is 1 or 3,",
  "the file src is copied to tgt.",
  "",
  "See also:       _else_, _expressions_,  _if_, _parsing_",
  "",
  "",
NULL
};

static char * chelp_text_endtry[] = {
  "endtry command",
  "",
  "The endtry command is used to terminate a try block.  Each",
  "try block must be terminated be a corresponding endtry command.",
  "",
  "Syntax:         endtry",
  "",
  "Parsing:        Expression",
  "",
  "Similar to:     Windows n/a command, Unix n/a command",
  "",
  "Example:        try",
  "                    copy aaa xxx",
  "                    copy bbb yyy",
  "                endtry",
  "",
  "                    This series of commands copies files aaa and bbb.  If",
  "an error occurs during copying the remaining commands are skipped",
  "until after the endtry.",
  "",
  "See also:       _catch_, _errors_, _throw_, _try_",
  "",
NULL
};

static char * chelp_text_endwhile[] = {
  "endwhile command",
  "",
  "The endwhile command is used to terminate a while loop.  Each",
  "while command must be terminated be a corresponding endwhile command.",
  "",
  "Syntax:         endwhile",
  "",
  "Parsing:        Expression",
  "",
  "Similar to:     Windows n/a, Unix done (terminates for) command",
  "",
  "Examples:       set n = 0",
  "                while n <= 4",
  "                    set f = 1",
  "                    set m = 2",
  "                    while m <= n",
  "                        set f = f * m",
  "                        set m = m + 1",
  "                    endwhile",
  "                    echo $n factorial is $f",
  "                    set n = n + 1",
  "                endwhile",
  "",
  "",
  "                    This series of commands displays:",
  "",
  "                    0 factorial is 1",
  "                    1 factorial is 1",
  "                    2 factorial is 2",
  "                    3 factorial is 6",
  "                    4 factorial is 24",
  "",
  "See also: _while_",
  "",
  "",
NULL
};

static char * chelp_text_exit[] = {
  "exit command",
  "",
  "The exit command exits the desh program or current script",
  "",
  "Syntax:             exit [-e] [ <n> ]",
  "",
  "    <n>             A number representing the exit code.  This",
  "number is available to the calling program.  The default is 0",
  "and represents successful execution.  Numbers other than 0,",
  "generally represent failure.",
  "",
  "Options: -e     Error.  Causes an exit if in a normal condition",
  "or an error condition.  Normally, an error condition causes",
  "most commands to be skipped.  However, exit -e executes even if",
  "in an error condition.  The -e should not be used within a",
  "try block because it will always exit.",
  "",
  "Notes:              The exit command should not be used within",
  "a function.  The return command should be used inside a function.",
  "",
  "Parsing:        Parameter",
  "",
  "Similar to:     Windows EXIT command, Unix exit command",
  "",
  "Example:        exit",
  "",
  "                    Exits desh.",
  "",
  "See also:       _parsing_, _try_",
  "",
NULL
};

static char * chelp_text_export[] = {
  "export command",
  "",
  "The export command is used to set the value of an",
  "environment variable.",
  "",
  "Syntax:         export <variable> [ = <expression> ]",
  "",
  "    <variable>      The name of the variable to export.  Variable",
  "names must begin with an alphabetic character or underscore (_).",
  "After the first character, variable names must contain only",
  "alphanumeric characters or underscores.",
  "",
  "    <expression>    Any valid expression.  If <expression> is",
  "omitted, <variable> must have already be defined with the set",
  "command.  If <expression> is present, <variable> is set with",
  "the result.",
  "",
  "Notes:          If <variable> does not exist, <expression> is required",
  "and the variable is created.  If <variable> does exist as a",
  "script or function variable, it is removed from that scope and",
  "recreated as an environment variable.",
  "",
  "                Exported variables are available as environment variables",
  "to child processes.  Non-exported variables are only accessible by",
  "the current desh process.",
  "",
  "Parsing:        Expression",
  "",
  "Similar to:     Windows n/a, Unix Bourne shell export",
  "",
  "Example:        set MYVAR1=\"one\"",
  "                set MYVAR2=\"two\"",
  "                export MYVAR3=\"three\"",
  "                export MYVAR1",
  "",
  "                    This series of commands creates three variables,",
  "but only two global/environment variables: MYVAR1 and MYVAR3.",
  "",
  "See also:       _parsing_, _set_, _variables_, _expressions_",
  "_http://en.wikipedia.org/wiki/Environment__variable_",
NULL
};

static char * chelp_text_for[] = {
  "for command",
  "",
  "The for command is used to set a variable to a set of values and then",
  "process commands for each value of the variable. Each for command must",
  "be terminated by a corresponding endfor command.",
  "",
  "Syntax 1:           for <var> in <parm-list>",
  "                        [ <commands> ]",
  "                    endfor",
  "",
  "Syntax 2:           for <var> = <start-exp> <to-downto> <end-exp>",
  "                        [ <commands> ]",
  "                    endfor",
  "",
  "Syntax 3:           for <var> <for-func> ( <parms> )",
  "                        [ <commands> ]",
  "                    endfor",
  "",
  "    <var>           The name of the variable set by for.  Each time through",
  "the loop, <var> is set to the next value.",
  "",
  "    <parm-list>     In syntax 1, this a list of values for <var>.  Each time",
  "through the loop, <var> has the next value in <parm-list>.  The loop",
  "terminates after all values in <parm-list> have been processed.",
  "",
  "    <start-exp>     In syntax 2, this an integer expression for the first",
  "value of <var>.",
  "",
  "    <to-downto>     In syntax 2, must be either \"to\" or \"downto\". \"to\"",
  "indicates <var> is incremented by 1 until the value is greater than",
  "<end-exp>.  \"downto\" indicates <var> is decremented by 1 until the value is",
  "less than <end-exp>.",
  "",
  "    <end-exp>       In syntax 2, this an integer expression for the last",
  "value of <var>.  The loop terminates when the value of <var> exceeds",
  "<end-exp>.",
  "",
  "    <for-func>      In syntax 3, <for-func> is a function that returns a",
  "list of zero or more strings. <for-func> must be one of:",
  "",
  "                        csvparse(<string>[,<delims>])   Parse a CSV string",
  "                        parse(<string>)                 Parse a string",
  "                        read(<file-name>)               Read a text file",
  "                        readdir(<dir-name>)             Read a directory",
  "",
  "                        csvparse(<string>[,<delims>]) Parse a CSV (comma",
  "separated values) string into tokens. <delims> is an optional",
  "argument that contains a list of delimiters. If <delims> is omitted,",
  "the default of ',\" is used which uses a comma as a delimiter.",
  "",
  "                        parse(<string>) Parse a string into tokens",
  "using spaces as delimiters.  The parsing is the same as parameter command",
  "parsing.",
  "",
  "                        read(<file-name>) Reads a text file and processes",
  "the for loop once for each line in the file with <var> containing the",
  "line.",
  "",
  "                        readdir(<dir-name>) Reads file names and",
  "directory names from a a directory.  Keep in mind that all but the topmost",
  "directory contains the directories \".\" and \"..\".",
  "",
  "Parsing:        Expression, parameter in for ... in",
  "",
  "Similar to:     Windows FOR command, Unix for command",
  "",
  "Example 1:      for COUNTER = 4 downto 1",
  "                    echo COUNTER is $COUNTER",
  "                endfor",
  "",
  "                    This series of commands displays:",
  "",
  "                    COUNTER is 4",
  "                    COUNTER is 3",
  "                    COUNTER is 2",
  "                    COUNTER is 1",
  "",
  "Example 2:      for GREEK in Alpha Beta Gamma Delta",
  "                    echo GREEK is $GREEK",
  "                endfor",
  "",
  "                    This series of commands displays:",
  "",
  "                    GREEK is Alpha",
  "                    GREEK is Beta",
  "                    GREEK is Gamma",
  "                    GREEK is Delta",
  "",
  "Example 3:      echo Alpha >tmp.txt",
  "                echo Beta >>tmp.txt",
  "                echo Gamma >>tmp.txt",
  "                echo Delta >>tmp.txt",
  "                for LIN read(\"tmp.txt\")",
  "                    echo LIN is $LIN",
  "                endfor",
  "",
  "                    This series of commands displays:",
  "",
  "                    LIN is Alpha",
  "                    LIN is Beta",
  "                    LIN is Gamma",
  "                    LIN is Delta",
  "",
  "See also:       _endfor_, _parsing_, _while_, _expressions_",
  "",
NULL
};

static char * chelp_text_function[] = {
  "function command",
  "",
  "The function command is used to create a user function definition.",
  "",
  "Syntax:             function <func-name> [ ( <arg> [ , ... ] ) ]",
  "                        [ <commands> ]",
  "                    endfunction",
  "",
  "    <func-name>     The name of the function being defined.  This name",
  "must be unique within the current script scope.  It is an error to define",
  "two functions with the same name. Function names must begin with an",
  "alphabetic character or underscore (_).  After the first character, function",
  "names must contain only alphanumeric characters or underscores.",
  "",
  "    <arg>           Argument to the function.  Argument names are local",
  "variables to the function and are set when the function is called.  Arguments",
  "are always called by value.",
  "",
  "Notes:              User functions are similar to functions in",
  "other programming languages.  They are reentrant and may be called",
  "recursively.",
  "",
  "                    Functions may be called as a command or as part of",
  "an expression.  When called as an expression, the calling expression must place",
  "the arguments in parentheses separated by commas.  When called as a command,",
  "the calling command places the arguments in the command line separated by spaces.",
  "",
  "                    Function arguments and variables first accessed with",
  "the function are local to the function and are deleted when the function returns.",
  "",
  "                    It is an error to pass too few arguments to a function,",
  "however too many arguments may be passed without error. If extra arguments",
  "are passed to the function, the first extra argument is accessed with $1",
  "the second with $2, etc.",
  "",
  "                    If a function returns a value, the return command is",
  "used to return the value.",
  "",
  "Parsing:            Expression",
  "",
  "Similar to:         Windows n/a, Unix function command",
  "",
  "Example 1:          function factorial(nn)",
  "                        set ff = 1",
  "                        for ii = 2 to nn",
  "                            set ff = ff * ii",
  "                        endfor",
  "                        return ff",
  "                    endfunction",
  "",
  "                    set fact = factorial(4)",
  "                    echo 4 factorial is $fact",
  "",
  "                        This series of commands displays:",
  "",
  "                    4 factorial is 24",
  "",
  "Example 2:          function rfactorial(nn)",
  "                        set ff = 1",
  "                        if nn > 1",
  "                            set ff = nn * rfactorial(nn - 1)",
  "                        endif",
  "                        return ff",
  "                    endfunction",
  "",
  "                    function show_fact(num)",
  "                        set fact = rfactorial(num)",
  "                        echo $num factorial is $fact",
  "                    endfunction",
  "",
  "                    show_fact 5",
  "",
  "                        This series of commands demonstrates a recursive",
  "function where rfactorial calls itself.  It also shows calling a function",
  "using an expression and a command. rfactorial is called in rwo places using",
  "and expression and show_fact is called with a command.  The output is:",
  "",
  "                    5 factorial is 120",
  "",
  "See also:           _endfunction_, _parsing_, _userfunctions_, _variables_",
  "",
NULL
};

static char * chelp_text_help[] = {
  "help command",
  "",
  "The help command displays documentation about a command, built-in function",
  "or other topic.  The help can also write all documentation files to a directory",
  "in html format so it cab accessed with a web browser.",
  "",
  "Syntax:             help [ -<opt> [...] ] [ <topic> ]",
  "",
  "    <opt>           A help option described below.",
  "",
  "    <topic>         The help topic or directory name is -h is specified.",
  "",
  "Options:    -f      Force.  Used with -h and forces directory to",
  "be removed.",
  "",
  "            -h      HTML. Writes all documentation as html files",
  "to the directory named by <topic>.  The main file is called",
  "index.htm.",
  "",
  "            -k      Keep.  Used with -h and keeps an existing",
  "directory in place.",
  "",
  "            -p      Page.  Displays help information one page at a",
  "time prompted by \"Continue?\" at the end of each page.  Answering \"N\"",
  "stops displaying help.  The default page length is 23 lines, but can",
  "be changed by setting the DESHPAGELEN variable.",
  "",
  "            -s      Search.  All documentation is searched for <topic>",
  "and the line is displayed along with the topic name and line number",
  "wherever <topic> is found.",
  "",
  "            -v      Verbose.  Used with -h to display extra messages.",
  "",
  "",
  "Notes:          If -h is specified, <topic> is used as the name of the",
  "directory to write the html files.  If -h is specified and the",
  "directory already exists, either -k (to keep) or -f (to remove)",
  "must also be specified.",
  "",
  "Parsing:            Parameter",
  "",
  "Similar to:         Windows cmd/?, Unix man command",
  "",
  "Examples:       help",
  "",
  "                    Displays main desh help page showing list of",
  "other help topics.",
  "",
  "                help -p commands",
  "",
  "                    Displays list of desh commands for which",
  "help is available.  Help is displayed one page at a time.",
  "",
  "                help -h -f deshhelp",
  "",
  "                    Writes all documentation as HTML files",
  "to the directory deshhelp.  The main help file is in index.htm.",
  "If the directory deshhelp already exists, it and its contents",
  "are removes before the files are written.",
  "",
  "",
  "",
NULL
};

static char * chelp_text_if[] = {
  "if command",
  "",
  "The if command is used to do conditional processing.  Each",
  "if command must be terminated be a corresponding endif command.",
  "",
  "Syntax:         if <expression>",
  "                    [ <commands> ]",
  "                [ else if <exp> ]",
  "                    [ <commands> ]",
  "                [ else ]",
  "                    [ <commands> ]",
  "                endif",
  "",
  "    <expression>    An expression that evaluates to either true or false.",
  "If <expression> is true, commands after the if are executed until an else",
  "or endif. An expression that evaluates to either true or false.",
  "If <expression> is false, commands are skipped until an else",
  "or endif.",
  "",
  "Notes:          Any number of else if <exp> commands may appear after",
  "an if command, but only one else without an if.",
  "",
  "                <expression> is evaluated using partial expression",
  "evaluation.  This means if the first part of a OR expression is true,",
  "the second part of the expression is not evaluated because the whole",
  "expression must be true.  Similarly, if the first part of an AND",
  "expression is false, the second part of the expression is not",
  "evaluated because the whole expression must be false.",
  "",
  "Parsing:        Expression",
  "",
  "Similar to:     Windows IF command, Unix if command",
  "",
  "Examples:       if ans = \"Y\" or ans = \"YES\"",
  "                    call do_it",
  "                else if ans = \"N\" or ans = \"NO\"",
  "                    call do_not_do_it",
  "                else",
  "                    echo $ans is an invalid answer.  Expected Y or N.",
  "                endif",
  "",
  "",
  "                    This series of commands, calls either do_it or",
  "do_not_do_it, depending on the value of the variable ans.",
  "",
  "                if num = 1; remove tmpfil; endif",
  "",
  "                    If the value of the variable num is 1, the file",
  "tmpfil is removed.",
  "",
  "See also:       _parsing_, _else_, _endif_, _expressions_",
  "",
  "",
NULL
};

static char * chelp_text_mkdir[] = {
  "mkdir command",
  "",
  "The mkdir command creates an empty directory.",
  "",
  "Syntax:             mkdir [-v] <dir> [...]",
  "",
  "    <dir>           The name of the directory to be created.",
  "",
  "Options:    -v      Verbose.  Shows the directory after it is created.",
  "",
  "Notes:              WINDOWS ONLY.  This command is only available as",
  "a built-in command on Windows versions of desh.  On Unix versions,",
  "the mkdir command already exists as an external command.",
  "",
  "Parsing:            Parameter",
  "",
  "Similar to:         Windows MKDIR command, Unix mkdir command",
  "",
  "Examples:       mkdir -v MyDir",
  "",
  "                    Create empty directory MyDir in the current",
  "working directory and display the name after it is created.",
  "",
  "See also:       _errors_",
  "",
NULL
};

static char * chelp_text_move[] = {
  "move command",
  "",
  "The move function moves or renames a file or directory. On Windows,",
  "directories can be moved, but not moved to a different device.",
  "",
  "Syntax:         move [-v] [-y [-f]] <source> [ ...] <target>",
  "",
  "    <source>    The name of the file or directory to be moved.",
  "",
  "    <target>    The new name of the file or directory.  It is an error",
  "the target already exists.",
  "",
  "Options:    -f     Force.  Only applies when -y has also been specified",
  "and indicates that if <target> is read-only file it is to be removed.",
  "",
  "            -v     Verbose.  Shows the files after each file is removed.",
  "",
  "            -y     Yes.  Specifies that if the target file already exits,",
  "it is to be overwritten.  It is an error if -y is not specified and",
  "the target file already exists. -y only applies to files.  If <target>",
  "is a directory, <source> is moved into the directory.",
  "",
  "Parsing:        Parameter",
  "",
  "Similar to:     Windows MOVE command, Unix mv command",
  "",
  "Examples:       move FileOne.txt FileTwo.txt",
  "",
  "                    Renames FileOne.txt to FileTwo.txt.",
  "",
  "                move MyDir ..",
  "",
  "                    Moves MyDir from the current directory to",
  "the parent directory.",
  "",
  "See also:       _errors_",
  "",
NULL
};

static char * chelp_text_remove[] = {
  "remove command",
  "",
  "The remove command removes files from a directory.",
  "",
  "Syntax:         remove [-f] [-v] <file> [...]",
  "",
  "    <file>      The file to be removed.",
  "",
  "Options:    -f     Force.  Specifies that if the file(s) are to be",
  "removed even if they have been made read-only.  Without -f, it is an",
  "error to try to remove a read-only file.  In addition, specifying",
  "-f causes no error if the file does not exist.",
  "",
  "            -v     Verbose.  Shows the files after each file is removed.",
  "",
  "Parsing:        Parameter",
  "",
  "Similar to:     Windows DEL command, Unix rm command",
  "",
  "Examples:       remove ..\\MyFile.txt",
  "",
  "                    Remove MyFile.txt from the parent directory of the current",
  "working directory.",
  "",
  "                remove -f \"File One.txt\" \"File Two.txt\"",
  "",
  "                    Removes \"File One.txt\" and \"File Two.txt\"",
  "even if they are read-only.",
  "",
  "See also:       _errors_",
  "",
NULL
};

static char * chelp_text_removedir[] = {
  "removedir command",
  "",
  "The removedir command removes a directory by recursively removing",
  "files and directories within it.",
  "",
  "Syntax:         removedir [-f] [-v] <dir> [...]",
  "",
  "    <dir>       The directory to be removed.",
  "",
  "Options:    -f     Force.  Specifies that if the files and directories",
  "are to be removed even if they have been made read-only.  Without -f, it is an",
  "error to try to remove a read-only file or directory.  In addition, specifying",
  "-f causes no error if the directory does not exist.",
  "",
  "            -v     Verbose.  Shows the files after each file is removed.",
  "",
  "Parsing:        Parameter",
  "",
  "Similar to:     Windows RMDIR/S command, Unix rm -R command",
  "",
  "Examples:       removedir -v MyDir",
  "",
  "                    Remove MyDir from the current",
  "working directory and display the name of each item after it is removed.",
  "",
  "                removedir -f \"Dir One\" \"Dir Two\"",
  "",
  "                    Removes \"Dir One\" and \"Dir Two\" even if they are",
  "read-only or contain read-only items.",
  "",
  "See also:       _errors_, _remove_, _rmdir_",
  "",
NULL
};

static char * chelp_text_return[] = {
  "return command",
  "",
  "The return command exits a user function and optionally returns",
  "the function value.",
  "",
  "Syntax:             return [ <func-rtn> ]",
  "",
  "    <func-rtn>      An  expression representing the function return value.  If",
  "<func-rtn> is omitted, the function returns no value.",
  "",
  "Notes:              The return command is only available within",
  "a function.  The exit command can be used outside a function.",
  "",
  "Parsing:            Expression",
  "",
  "Similar to:         Windows n/a, Unix return command",
  "",
  "Example:            function square(num)",
  "                        return num * num",
  "                    endfunction",
  "                    echo Four squared is ${square(4)}",
  "",
  "                        This series of commands displays:",
  "",
  "                    Four squared is 16",
  "",
  "See also:           _function_, _parsing_, _userfunctions_",
  "",
NULL
};

static char * chelp_text_rmdir[] = {
  "rmdir command",
  "",
  "The rmdir command removes an empty directory.",
  "",
  "Syntax:             rmdir [-v] <dir> [...]",
  "",
  "    <dir>           The directory to be removed.",
  "",
  "Options:    -v      Verbose.  Shows the directory after it is removed.",
  "",
  "Notes:              WINDOWS ONLY.  This command is only available as",
  "a built-in command on Windows versions of desh.  On Unix versions,",
  "the rmdir command already exists as an external command.",
  "",
  "                    It is an error if the directory is not empty.  To",
  "remove a directory and its contents, use the removedir command.",
  "",
  "Parsing:            Parameter",
  "",
  "Similar to:         Windows RMDIR command, Unix rmdir command",
  "",
  "Examples:       rmdir -v MyDir",
  "",
  "                    Remove empty directory MyDir from the current",
  "working directory and display the name after it is removed.",
  "",
  "See also:       _errors_, _remove_, _removedir_",
  "",
NULL
};

static char * chelp_text_set[] = {
  "set command",
  "",
  "The set command is used to set the value of a variable.",
  "",
  "Syntax 1:           set <variable> = <expression>",
  "",
  "Syntax 2:           set",
  "",
  "    <variable>      The name of the variable to be set.  Variable",
  "names must begin with an alphabetic character or underscore (_).",
  "After the first character, variable names must contain only",
  "alphanumeric characters or underscores.",
  "",
  "    <expression>    Any valid expression.  String literals must",
  "be enclosed in quotation marks (\" or ').  Boolean literals must",
  "be true or false.  Numbers are stored as 64-bit integers and must",
  "be from -9223372036854775808 through 9223372036854775807.",
  "",
  "Notes:              If <variable> does not exist, it is automatically",
  "defined at the local level if in a function, or at the script level",
  "if not in a function. Use the export command to set a global variable.",
  "",
  "                    If no arguments are given, the value of all",
  "variables is displayed to stdout.",
  "",
  "Parsing:            Expression, however set with no arguments may",
  "have the output redirected.",
  "",
  "Similar to:         Windows SET command, Unix a=b",
  "",
  "Example:            set xx = 2",
  "                    set yy = 1 + xx * 3",
  "                    set aa = \"xx\"",
  "                    set bb = \"$yy\"",
  "                    echo xx=$xx yy=$yy aa=$aa bb=$bb",
  "",
  "                        This series of commands displays:",
  "",
  "                        xx=2 yy=7 aa=xx bb=7",
  "",
  "See also:       _parsing_, _export_, _variables_, _expressions_",
NULL
};

static char * chelp_text_shift[] = {
  "shift command",
  "",
  "The shift command shifts the position of one or command arguments.",
  "",
  "Syntax:         shift [ <n> ]",
  "",
  "    <n>         The number of arguments to shift.  If <n> is not",
  "specified, the default is 1.",
  "",
  "Notes:          The shift command changes the values of the command arguments",
  "$1 through $9 by copying each argument to the previous one.  The value of",
  "$2 is copied to $1, the value of $3 is copied to $2, and so on.",
  "The name argument ($0) is left unchanged.",
  "",
  "Parsing:        Parameter",
  "",
  "Similar to:     Windows SHIFT command, Unix shift command",
  "",
  "Example 1:      function myfunc",
  "                    for ARG = 1 to $ARGC",
  "                        echo $0 $1",
  "                        shift",
  "                    endfor",
  "                endfunction",
  "",
  "                myfunc one two three four",
  "",
  "                    This series of commands uses shift to cycle through",
  "each of the function arguments.  The output is:",
  "",
  "                myfunc one",
  "                myfunc two",
  "                myfunc three",
  "                myfunc four",
  "",
  "See also:       _parsing_",
NULL
};

static char * chelp_text_shopt[] = {
  "shopt command",
  "",
  "The shopt sets, clears and displays shell options.",
  "",
  "Syntax:             shopt [-p] [-s | -u] [ <option> [ ... ] ]",
  "",
  "    <option>        The name of the option.  Options are a single",
  "character and are described below.",
  "",
  "Options: -p         Print.  Displays option value(s) using the shopt",
  "command to set or clear the option.  \"shopt -s\" indicates the",
  "option is set.    \"shopt -u\" indicates the option is not set.",
  "",
  "         -s         Set.  Sets the specified option.",
  "",
  "         -u         Unset.  Unsets (clears) the specified option.",
  "",
  "Shell Options:      Shell options are a single character as follows:",
  "",
  "        a           Display abbreviated version number when desh is",
  "started.  Only has an effect when present on desh command line.",
  "",
  "        d           Causes extra debugging information to be displayed",
  "including the names of external programs when they are run.  Also,",
  "the set command with no parameters shows the scope of each variable",
  "and user functions.",
  "",
  "        f           Causes fileset parameters such as * to be",
  "expanded in the command line.  If f is not set (the default",
  "on Windows), ^ must precede the fileset to be expanded, e.g. ^*.txt",
  "The f option is set by default on Unix systems.",
  "",
  "        i           Causes desh command and variable names to be",
  "case insensitive.  This option is set by default on Windows systems.",
  "",
  "        n           Inhibits the execution of deshrc when desh is run.",
  "Only has an effect when present on desh command line.",
  "",
  "        p           Causes desh to pause for input before exiting.  This",
  "can be useful when desh is run from a window that disappears upon",
  "completion.",
  "",
  "        v           Verbose.  Causes some debugging information to be",
  "displayed.",
  "",
  "        w           Causes behavior identified with Windows systems.",
  "This option is set by default on Windows systems.  Effects of w are:",
  "",
  "                        With w, the alternate name for deshrc is deshrc.ini",
  "Without w, the alternate name is .deshrc",
  "",
  "                        With w, a slash (/) in the first token is a delimiter.",
  "Without w,  a slash (/) in the first token is not a delimiter and is assumed",
  "to be part of a file name.",
  "",
  "                        With w, both PATH and PATHEXT are used to search",
  "for external commands.  Without w, only PATH is used to search",
  "for external commands.",
  "",
  "                        With w, in a file pattern ending in *.* , the final",
  ".* is stripped so the pattern ends in simply *.  Without w, file patterns",
  "are not reinterpreted.",
  "",
  "        x           Causes desh to exit after processing command line.",
  "Only has an effect when present on desh command line.",
  "",
  "Parsing:            Parameter",
  "",
  "Similar to:         Windows n/a, Linux shopt command",
  "",
  "Examples:           shopt",
  "",
  "                        Displays all options using \"shopt -s\" for options",
  "that are set and \"shopt -u\" for options not set.",
  "",
  "                shopt -s f",
  "",
  "                    Sets the f option, turning on fileset command",
  "line expansion.",
  "",
  "See also:       _desh_, _parsing_",
NULL
};

static char * chelp_text_start[] = {
  "start command",
  "",
  "The start command executes a desh program and continues without",
  "waiting for the program to complete.",
  "",
  "Syntax:             start [-v] <program> [ <arg> ...]",
  "",
  "    <program>       The name of the program to run.  The PATH is",
  "searched in the same way as when start is omitted.",
  "",
  "    <arg>           Argument to the program.  Any number of",
  "arguments are permitted.",
  "",
  "Options:    -v     Verbose.  Shows the pid of the started process.",
  "",
  "Notes:              The start command runs a program the same as when",
  "start is omitted, except that desh does not wait for the program to",
  "complete before continuing.",
  "",
  "                    The start command creates a separate operating",
  "system process for the command.  The operating system assigns a unique",
  "process identification number (pid) to the process.  The start command",
  "sets the variable DESHSTARTPID to the pid of the started process.",
  "",
  "                    The wait command can be used to wait for started",
  "commands to complete.                    .",
  "",
  "Parsing:            Parameter",
  "",
  "Similar to:         Windows START command, Unix & command terminator",
  "",
  "Example:            start program1 fileA fileB",
  "                    start program2 fileC",
  "",
  "                        Searches PATH for program1 and runs it",
  "with arguments fileA and fileB.  Then immediately, without waiting",
  "for program1 to complete, runs program2 with argument fileC.  The script",
  "then continues while program1 and program2 are running.",
  "",
  "See also:           _wait_, _commands_",
  "",
NULL
};

static char * chelp_text_throw[] = {
  "throw command",
  "",
  "The throw command always fails and is used to manually create",
  "an error condition.  The throw command is often used within a try block.",
  "",
  "Syntax:         throw [ <string expression> ]",
  "",
  "Parsing:        Expression",
  "",
  "    <string expression>    A string expression that is part of the error",
  "                message created by throw.",
  "",
  "Similar to:     Windows n/a command, Unix n/a command",
  "",
  "Example 1:      if ans <> \"YES\" and ans <> \"NO\"",
  "                    throw \"Expecting YES or NO.",
  "                endif",
  "",
  "                    This series of commands checks the variable ans,",
  "and if is neither \"YES\" nor \"NO\", an error is thrown.",
  "",
  "Example 2:      try",
  "                    copy aaa xxx",
  "                    copy bbb yyy",
  "                    copy ccc zzz",
  "                catch",
  "                    echo A COPY statement failed with error number $ERRNUM",
  "                    throw ERRMSG",
  "                endtry",
  "",
  "                    If an error occurs while copying aaa, bbb, or ccc,",
  "an error message is displayed using echo and throw is used to",
  "create an error condition.",
  "",
  "See also:       _parsing_, _errors_, _catch_, _try_",
  "",
NULL
};

static char * chelp_text_time[] = {
  "time command",
  "",
  "The time command displays the time taken to complete a command.",
  "",
  "Syntax:             time [-h] [-p] <command> [ <arguments> ]",
  "",
  "    <command>       The command to be timed.",
  "",
  "    <arguments>     The arguments to <command>.",
  "",
  "Options:    -h      Use a high-precision timer.",
  "",
  "            -p      Use the precise traditional POSIX format.",
  "",
  "Notes:              The elapsed (real), program CPU (user) and system CPU (sys)",
  "times are displayed to stderr.",
  "",
  "Parsing:            Parameter",
  "",
  "Similar to:         Windows n/a, Unix time command",
  "",
  "Examples:           time copy SrcFile TgtFile",
  "",
  "                        Copies SrcFile to SrcFile, then displays the amount",
  "of time taken to do the copy.                    .",
  "",
  "See also:       _parsing_",
NULL
};

static char * chelp_text_try[] = {
  "try command",
  "",
  "The try command is used to ignore or catch command errors.",
  "The try command must be followed by another command, or",
  "be followed by commands terminating with an endtry command.",
  "",
  "Syntax:         try [-b] [-q] <command>",
  "",
  "                    -or-",
  "",
  "                try [-b] [-q]",
  "                    [ <try commands> ]",
  "                [ catch ]",
  "                    [ <recovery commands> ]",
  "                endtry",
  "",
  "    <command>           Immediately after try, is executed,",
  "but any error does not affect script processing.",
  "",
  "    <try commands>      Are executed, but any error causes commands to be",
  "skipped until the corresponding catch or endtry statement is reached,",
  "",
  "    <catch commands>    If present after a catch, are executed only if an error",
  "occurs in <try commands>.  If <catch commands> are not present, an error",
  "during <try commands> causes all commands to be skipped until after the",
  "endtry.  All <catch commands> are skipped if no error occurs during",
  "<try commands>.",
  "",
  "Options:    -b     Break. Causes a user break (user presses control-C)",
  "to be considered an error trapped by try.  Without -b, a user",
  "break stops script processing.",
  "",
  "            -q     Quiet. Causes any error message to be suppressed.",
  "Without -q, error messages are displayed.",
  "",
  "Notes:              If -q is used with try, <catch commands> can still display",
  "error messages using the ERRCMD, ERRMSG and ERRNUM built-in variables.",
  "",
  "                    The throw command can be used to generate an error",
  "condition.  In other words, the throw command always fails.",
  "",
  "Parsing:        Expression",
  "",
  "Similar to:     Windows n/a command, Unix n/a command",
  "",
  "Example 1:      try -q",
  "                    copy aaa xxx",
  "                    copy bbb yyy",
  "                    copy ccc zzz",
  "                catch",
  "                    echo A COPY statement failed with error number $ERRNUM",
  "                    echo The error message is: $ERRMSG",
  "                endtry",
  "",
  "                    This series of commands copies files aaa, bbb, and ccc.  If",
  "an error occurs during copying, no message is displayed, but",
  "the catch commands are executed.  The catch commands display",
  "an error.  If all copy commands are successful, the",
  "catch commands are skipped.",
  "",
  "Example 2:      try -q",
  "                    try",
  "                        remove xxx",
  "                        remove yyy",
  "                        remove zzz",
  "                    endtry",
  "                    copy aaa xxx",
  "                    try copy bbb yyy",
  "                    copy ccc zzz",
  "                catch",
  "                    echo A COPY statement failed with error number $ERRNUM",
  "                    echo The error message is: $ERRMSG",
  "                endtry",
  "",
  "                    If any of the remove commands receives an error,",
  "an error message is displayed and the remaining removes are skipped.",
  "If an error occurs during copying aaa or ccc, no message is displayed, but",
  "the catch commands are executed.  The try before copy bbb causes the copy ccc",
  "to proceed even if the copy bbb fails.",
  "",
  "See also:       _parsing_, _catch_, _endtry_, _errors_, _throw_",
NULL
};

static char * chelp_text_type[] = {
  "type command",
  "",
  "The type command displays one or more text files to stdout.",
  "",
  "Syntax:         type [-n] [ <file> ] [ ...]",
  "",
  "    <file>      The file to be displayed.  If no <file> is specified,",
  "lines are read from stdin.",
  "",
  "Options: -n     Specifies that lines are to be numbered with",
  "the first line 1.  If more than one file is specified,",
  "numbering continues with each file and does not begin",
  "again at 1.",
  "",
  "Parsing:        Parameter",
  "",
  "Similar to:     Windows TYPE command, Unix cat command",
  "",
  "Examples:       type MyFile.txt.",
  "",
  "                    Displays the contents of MyFile.txt to stdout.",
  "",
  "                type file1.txt file2.txt file3.txt >files123.txt",
  "",
  "                    Writes the contents of file1.txt, file2.txt",
  "and file3.txt to files123.txt.  This combines this three",
  "files into one larger file.",
  "",
  "See also:       _redirection_",
  "",
NULL
};

static char * chelp_text_wait[] = {
  "wait command",
  "",
  "The wait command waits for start'd processes to finish.",
  "",
  "Syntax:         wait [-i] [-v] <pid> [ <pid> [ ... ] ]",
  "                wait [-i] [-v] -a",
  "",
  "    <pid>      The process identification number (pid) of the",
  "process to wait for completion.",
  "",
  "Options:    -a     All.  Specifies wait until all commands",
  "begun with the start command have completed running.  If there",
  "are no commands running, the wait does nothing.",
  "",
  "            -i     Ignore.  Ignores errors.  Causes invalid pid",
  "and command completion errors to be ignored.  An invalid pid is one",
  "that was not started with the start command or one that has been cleared",
  "by a previous wait commnad.  It is an error to wait on the same pid",
  "more than once.",
  "",
  "            -v     Verbose.  Shows the pids before waiting.",
  "",
  "Notes:              The wait command can only wait for processes that",
  "have been started with the start command.  If any of the waited commands fails,",
  "the wait command fails unless -i is specified.",
  "",
  "Parsing:        Parameter",
  "",
  "Similar to:     Windows n/a, Unix wait command",
  "",
  "Examples:       start command1",
  "                set pidlist=DESHSTARTPID",
  "",
  "                start command2",
  "                set pidlist=pidlist & \" \" & DESHSTARTPID",
  "",
  "                wait $^pidlist",
  "",
  "                    This series of commands starts command1 and command2",
  "so that they run concurrently. The pids of the started",
  "commands are kept in the space delimited variable pidlist.",
  "The wait command is then used to wait for command1 and",
  "command2 to complete.  Note the use of $^pidlist on the",
  "wait command.  The ^ is necessary so that each element",
  "of pidlist is parsed.  If the command is \"wait $pidlist\"",
  "and the pids were 1024 and 2048, then the command would",
  "be interpreted with one argument, like this:",
  "                        wait \"1024 2048\"",
  "                    Using the ^ makes the command interpreted with two",
  "arguments, like this:",
  "                        wait \"1024\" \"2048\"",
  "",
  "See also:       _start_, _parsing_",
  "",
NULL
};

static char * chelp_text_while[] = {
  "while command",
  "",
  "The while command is used to repeatedly process commands",
  "in a loop.  Each while command must be terminated by",
  "a corresponding endwhile command.",
  "",
  "Syntax:             while <expression>",
  "                        [ <commands> ]",
  "                    endwhile",
  "",
  "    <expression>    An expression that evaluates to either true or false.",
  "If <expression> is true, commands after the while are executed until an",
  "endwhile and then execution begins again with the while command,",
  "creating a loop.  If <expression> is false, commands are skipped until",
  "the endwhile.",
  "",
  "Notes:              <expression> is evaluated using partial expression",
  "evaluation.  This means if the first part of a OR expression is true,",
  "the second part of the expression is not evaluated because the whole",
  "expression must be true.  Similarly, if the first part of an AND",
  "expression is false, the second part of the expression is not",
  "evaluated because the whole expression must be false.",
  "",
  "Parsing:            Expression",
  "",
  "Similar to:         Windows FOR command, Unix for command",
  "",
  "Example:            set COUNTER=1",
  "                    while COUNTER <= 4",
  "                        echo COUNTER is $COUNTER",
  "                        set COUNTER = COUNTER + 1",
  "                    endwhile",
  "",
  "                        This series of commands displays:",
  "",
  "                    COUNTER is 1",
  "                    COUNTER is 2",
  "                    COUNTER is 3",
  "                    COUNTER is 4",
  "",
  "See also:           _parsing_, _endwhile_, _expressions_",
NULL
};

static char * chelp_text_addtodate[] = {
  "addtodate built-in expression function",
  "",
  "Adds an interval to a date and returns a date.  All",
  "arguments are expressed as strings, with additional arguments used",
  "to describe the date formats.",
  "",
  "    Syntax:     <date> = addtodate(<frdat>,<frfmt>,<intvl>,<ifmt>,<fmt>)",
  "",
  "        <date>      Return value of addtodate() in the date format",
  "specified by <fmt>.",
  "",
  "        <frdat>     The date origin to which the interval is",
  "added.  This date must be in the format specified by <frfmt>.",
  "",
  "        <frfmt>     The date format of <frdat>.  See _datefmts_",
  "for information on date formats.",
  "",
  "        <intvl>     The interval to be added to <frdate>.",
  "This interval must be in the format specified by <ifmt>.",
  "",
  "        <ifmt>      The format of <intvl>.  See _datefmts_",
  "for information on date formats.",
  "",
  "        <fmt>       The output date format of the addtodate() result.",
  "See _datefmts_ for information on date formats.",
  "",
  "    Example:    set datfmt=\"%Y%m%d\"",
  "                set today=now(datfmt)",
  "                set tomorrow=addtodate(today, datfmt, 1, \"%nd\", datfmt)",
  "",
  "                    This example calculates the value of tomorrow",
  "in YYYYMMDD format by adding one day to the current date.",
  "",
  "See also:        _datefmts_, _now_, _subdates_, _subfromdate_",
NULL
};

static char * chelp_text_argv[] = {
  "argv built-in expression function",
  "",
  "Returns the function/program argument n.",
  "Arguments are passed in when a function is called, by a call or dot (.)",
  "statement and by running a program.",
  "",
  "    Syntax:     <arg> = argv(<n>)",
  "",
  "        <arg>      Return string of argv().",
  "",
  "        <n>        The argument number. argv(0) is the name of the",
  "function or program.  If <n> is larger than ARGC (the highest argument",
  "number), an empty string is returned.",
  "",
  "    Example:    for ii = 0 to ARGC; echo $ii=${argv(ii)}; endfor",
  "",
  "                    This example displays all arguments.",
  "",
  "See also:       _variables_",
NULL
};

static char * chelp_text_basename[] = {
  "basename built-in expression function",
  "",
  "Returns the non-directory portion of a path name.",
  "",
  "    Syntax:     <base> = basename(<path-name>)",
  "",
  "        <base>          The portion of the file or path name after the",
  "directory name.  This includes the file extension, if any.",
  "",
  "        <path-name>     The source file or path name from which the base",
  "name is extracted.",
  "",
  "    Note;   There is no built-in function to return only a file name",
  "without the extension, however a user function is easily created.",
  "For example:",
  "",
  "",
  "        function file_without_extension(fn)",
  "            return left(basename(fn), len(basename(fn)) - len(extname(fn)))",
  "        endfunction",
  "",
  "    Example:    set filename=\"D:\\Downloads\\jre-7u25-windows-i586.exe\"",
  "                set filebase=basename(filename)",
  "                echo filename=$filename",
  "                echo filebase=$filebase",
  "",
  "                    This example displays:",
  "",
  "                        filename=D:\\Downloads\\jre-7u25-windows-i586.exe",
  "                        filebase=jre-7u25-windows-i586.exe",
  "",
  "See also:        _dirname_, _extname_",
  "",
  "",
NULL
};

static char * chelp_text_char[] = {
  "char built-in expression function",
  "",
  "Returns the ASCII character from a number.",
  "",
  "    Syntax:     <char> = char(<number>)",
  "",
  "        <char>      Character returned by char().",
  "",
  "        <number>    Number between 1 and 255 the ASCII character.",
  "To convert an ASCII character to a number, use code().",
  "See: _http://en.wikipedia.org/wiki/ASCII_.",
  "",
  "    Example:    echo Abc=${char(65) & char(98) & char(99)}",
  "",
  "                    This example displays:",
  "",
  "                        Abc=Abc",
  "",
  "See also:        _code_",
NULL
};

static char * chelp_text_chbase[] = {
  "chbase built-in expression function",
  "",
  "Chases the base of a numeric string.  Bases supported are 2, 4, 8 10 and 16.",
  "In base 16, A-F is used to represent digits 10-15.  As is all arithmetic,",
  "conversions are done using 64-bit integers.",
  "",
  "    Syntax:     <result-str> = chbase(<num-string>, <from-base>, <to-base>)",
  "",
  "        <result-str>    A string containing the result after <num-string> has",
  "been converted from numeric base <from-base> to",
  "numeric base <to-base>.",
  "",
  "        <num-string>    A string representing the number to be converted.  If this",
  "is not originally a string, it is converted to a string",
  "prior to base connversion.",
  "",
  "        <from-base>     A number representing the source base of <num-string>.  For",
  "base 16, A-F (or a-f) represent digits 10-15. <from-base>",
  "must be either 2, 4, 8 10 or 16.",
  "",
  "        <to-base>       A number representing the target base of the conversion.",
  "A-F is used to represent digits 10-15. <to-base>",
  "must be either 2, 4, 8 10 or 16.",
  "",
  "    Example:    echo Chbase 1: ${chbase(\"12\", 10, 16)}",
  "                echo Chbase 2: ${chbase(\"12\", 10,  8)}",
  "                echo Chbase 3: ${chbase(\"12\",  8, 16)}",
  "                echo Chbase 4: ${chbase(\"12\",  8, 10)}",
  "                echo Chbase 5: ${chbase(10 + 2,8, 10)}",
  "                echo Chbase 6: ${chbase(-2  , 10, 16)}",
  "",
  "                    This example displays:",
  "",
  "                        Find 1: 2",
  "                        Chbase 1: C",
  "                        Chbase 2: 14",
  "                        Chbase 3: A",
  "                        Chbase 4: 10",
  "                        Chbase 5: 10",
  "                        Chbase 6: FFFFFFFFFFFFFFFE",
  "",
  "See also:        _left_, _len_, _mid_, _right_",
NULL
};

static char * chelp_text_code[] = {
  "code built-in expression function",
  "",
  "Returns the ASCII code of a character.",
  "",
  "    Syntax:     <number> = code(<char>)",
  "",
  "        <number>    Number returned by code().",
  "",
  "        <char>      Any ASCII character.  If <char> is a string longer",
  "than one character, code() returns the code for the first character.",
  "To convert a number to an ASCII character, use char().",
  "See: _http://en.wikipedia.org/wiki/ASCII_.",
  "",
  "    Example:    echo ${code(\"A\")}, ${code(\"b\")}, ${code(\"c\")}",
  "",
  "                    This example displays:",
  "",
  "                        65, 98, 99",
  "See also:        _char_",
NULL
};

static char * chelp_text_dirname[] = {
  "dirname built-in expression function",
  "",
  "Returns the directory portion of a path name.",
  "",
  "    Syntax:     <dir> = dirname(<path-name>)",
  "",
  "        <dir>           The directory portion of the file or path name.",
  "If the path name does not have a directory, a dot (.) is returned",
  "indicating the current directory.",
  "",
  "        <path-name>     The source file or path name from which the directory",
  "name is extracted.",
  "",
  "    Example:    set filename=\"D:\\Downloads\\Y2013\\jre-7u25-windows-i586.exe\"",
  "                set filedir=dirname(filename)",
  "                echo filename=$filename",
  "                echo filedir =$filedir",
  "",
  "                    This example displays:",
  "",
  "                        filename=D:\\Downloads\\Y2013\\jre-7u25-windows-i586.exe",
  "                        filedir =D:\\Downloads\\Y2013",
  "",
  "See also:        _basename_, _extname_",
  "",
NULL
};

static char * chelp_text_extname[] = {
  "extname built-in expression function",
  "",
  "Returns the extension portion of a path name with a leading dot.",
  "",
  "    Syntax:     <ext> = extname(<path-name>)",
  "",
  "        <ext>           The extension portion of the file or path name",
  "with a leading dot or period.  If the path name has no path name, \"\"",
  "is returned.",
  "",
  "        <path-name>     The source file or path name from which the directory",
  "name is extracted.",
  "",
  "    Note;   The path name is searched backwards from the end, stopping",
  "when the first of three conditions is met: 1) the beginning of the path name",
  "is reached, 2) a path separator is reached (\\ on Windows), 3) a dot (.)",
  "is reached.  If a dot is reached, all characters after and including the",
  "dot are returned. Otherwise \"\" is returned.",
  "",
  "    Example:    set filename=\"D:\\Downloads\\Y2013\\jre-7u25-windows-i586.exe\"",
  "                set fileext=extname(filename)",
  "                echo filename=$filename",
  "                echo fileext =$fileext",
  "",
  "                    This example displays:",
  "",
  "                        filename=D:\\Downloads\\Y2013\\jre-7u25-windows-i586.exe",
  "                        fileext =.exe",
  "",
  "See also:        _basename_, _dirname_",
  "",
  "",
  "",
NULL
};

static char * chelp_text_find[] = {
  "find built-in expression function",
  "",
  "Searches one string within another string and returns the index of first occurence",
  "of the search string within the target string.  The search is done with a",
  "case-sensitive search.  The index of the first character is 1 and zero is",
  "returned if the string is not found.  If <string-to-find> is empty, then 1 is returned,",
  "regardless of the contents of <target-string>.",
  "",
  "    Syntax:     <index> = find(<string-to-find>, <target-string>)",
  "",
  "        <index>     The index of <string-to-find> within <target-string>",
  "",
  "",
  "        <string-to-find>    The string to search within <source-string>.",
  "The search is case sensitive.",
  "",
  "        <target-string>     The string which is searched.",
  "",
  "",
  "    Example:    echo Find 1: ${find(\"BCD\", \"ABCDEF\")}",
  "                echo Find 2: ${find(\"bcd\", \"ABCDEF\")}",
  "                echo Find 3: ${find(\"\", \"ABCDEF\")}",
  "                echo Find 4: ${find(\"A\", \"BANANA\")}",
  "",
  "                    This example displays:",
  "",
  "                        Find 1: 2",
  "                        Find 2: 0",
  "                        Find 3: 1",
  "                        Find 4: 2",
  "",
  "See also:        _left_, _len_, _mid_, _right_",
NULL
};

static char * chelp_text_finfo[] = {
  "finfo built-in expression function",
  "",
  "Returns information about a file or directory.",
  "",
  "    Syntax:     <info> = finfo(<file-name>, <info-type>)",
  "",
  "        <info>          A string containing information about the",
  "file or directory.",
  "",
  "        <file-name>     The file, directory or file system object name.",
  "",
  "        <info-type>     A case-insensitive string",
  "indicating the type of information to be returned.",
  "<info-type> must be one of the types listed below.",
  "",
  "            ACCDATE     Returns the file last access date in",
  "YYYY-MM-DD HH:MM:SS format which is specified in desh date",
  "functions as \"%Y-%m-%d %H:%M:%S\".            .",
  "",
  "            CRDATE      Returns the file creation date in",
  "YYYY-MM-DD HH:MM:SS format which is specified in desh date",
  "functions as \"%Y-%m-%d %H:%M:%S\".            .",
  "",
  "            MODDATE     Returns the file modification date in",
  "YYYY-MM-DD HH:MM:SS format which is specified in desh date",
  "functions as \"%Y-%m-%d %H:%M:%S\".            .",
  "",
  "            OWNER       Returns a string indicating the owner",
  "of file system object.",
  "",
  "            SIZE        Returns a number indicating the number",
  "of bytes used by a file.  Zero is returned if <file-name>",
  "references a directory.",
  "",
  "            TYPE        Returns a string indicating the type",
  "of file system object as follows:",
  "",
  "                            NONE    The object does not exist.",
  "                            FILE    The object is a regular file.",
  "                            DIR     The object is a directory.",
  "                            LINK    The object is a link to another object.",
  "                            PIPE    The object is a pipe.",
  "",
  "                        TYPE cannot cause an error.",
  "",
  "    Example:    echo  ${finfo(\"C:\\WINDOWS\", \"TYPE\")}",
  "                echo  ${finfo(\"C:\\WINDOWS\", \"owner\")}",
  "                echo  ${finfo(\"\\/*Bad File*\\/\", \"Type\")}",
  "",
  "                    This example displays:",
  "",
  "                        DIR",
  "                        Administrators",
  "                        NONE",
  "",
  "See also:        _expressions_",
  "",
NULL
};

static char * chelp_text_left[] = {
  "left built-in expression function",
  "",
  "Returns characters from the left of a string.",
  "",
  "    Syntax:     <substr> = left(<string>, <len>)",
  "",
  "        <substr>    String returned by left().",
  "",
  "        <string>    The source string from which the leftmost",
  "characters are extracted.",
  "",
  "        <len>       A number indicating the number of characters",
  "to be extracted.  If <len> is larger than the length of <string>,",
  "the entire <string> is returned.",
  "",
  "    Example:    set str=\"$%64$%65$%73$%78\"  # \"desh\"",
  "                set nch=3",
  "                set lstr=left(str,nch)",
  "                echo str=$str left(str,nch)=$lstr",
  "",
  "                    This example displays:",
  "",
  "                        str=desh left(str,nch)=des",
  "",
  "See also:        _len_, _mid_, _right_",
NULL
};

static char * chelp_text_len[] = {
  "len built-in expression function",
  "",
  "Returns the length of a character string.",
  "",
  "    Syntax:     <strlen> = len(<string>)",
  "",
  "        <strlen>    Number of characters in <string>.",
  "",
  "        <string>    The source string from which the length",
  "is returned.",
  "",
  "    Example:    set str=\"$%64$%65$%73$%78\"  # \"desh\"",
  "                set nch=len(str)",
  "                echo str=$str len(str)=$nch",
  "",
  "                    This example displays:",
  "",
  "                        str=desh len(str)=4",
  "",
  "See also:        _left_, _mid_, _right_",
NULL
};

static char * chelp_text_lower[] = {
  "lower built-in expression function",
  "",
  "Returns the string in all lower case characters.",
  "",
  "    Syntax:     <lowstr> = lower(<string>)",
  "",
  "        <lowstr>    The <string> with all upper case",
  "characters converted to lower case.",
  "",
  "        <string>    The source string.",
  "",
  "    Example:    set str=\"Alpha BETA Gamma\"",
  "                set low=lower(str)",
  "                echo str=$str lower(str)=$low",
  "",
  "                    This example displays:",
  "",
  "                        str=Alpha BETA Gamma lower(str)=alpha beta gamma",
  "",
  "See also:        _upper_",
NULL
};

static char * chelp_text_matches[] = {
  "matches built-in expression function",
  "",
  "Returns TRUE if a string matches a pattern",
  "",
  "    Syntax:     <patmat> = matches(<string>, <pattern>)",
  "",
  "        <patmat>    TRUE if <string> matches <pattern>, FALSE",
  "if it does not.",
  "",
  "        <string>    The string to be matched against the pattern.",
  "",
  "        <pattern>   The pattern to which <string> is compared.",
  "The pattern matching is the same as fileset substitution and",
  "the dir command.  The matching may always uses a case sensitive comparision.",
  "Wildcards used in <pattern> and are:",
  "",
  "                        * matches zero or more characters",
  "                        ? matches any single character",
  "                        [<char_list>] matches a single character against",
  "a list or range of characters.  Examples:",
  "",
  "                            [0-9] matches a digit",
  "                            [0-9a-f] matches a hexadecimal digit",
  "                            [aeiou] matches a vowel.",
  "",
  "",
  "    Example:    echo Match 1: ${matches(\"ABCED\", \"abc*\")}",
  "                echo Match 2: ${matches(\"ABCED\", \"ABC*\")}",
  "                echo Match 3: ${matches(\"Ball\", \"B[aeiou]ll\")}",
  "                echo Match 4: ${matches(\"Yes\", \"[Yy][Ee][Ss]\")}",
  "                echo Match 5: ${matches(\"Y\", \"[Yy][Ee][Ss]\")}",
  "                echo Match 6: ${matches(\"Yes\", \"[Yy]??\")}",
  "",
  "                    This example displays:",
  "",
  "                        Match 1: FALSE",
  "                        Match 2: TRUE",
  "                        Match 3: TRUE",
  "                        Match 4: TRUE",
  "                        Match 5: FALSE",
  "                        Match 6: TRUE",
  "",
  "See also:        _dir_",
NULL
};

static char * chelp_text_mid[] = {
  "mid built-in expression function",
  "",
  "Returns characters from the middle of a string.",
  "",
  "    Syntax:     <substr> = mid(<string>, <index>, <len>)",
  "",
  "        <substr>    String returned by mid().",
  "",
  "        <string>    The source string from which the",
  "characters are extracted.",
  "",
  "        <index>     The index of the first character extracted from",
  "source string.  The index of the first character is 1.  If <index>",
  "is less than 1 or greater than the length of <string>, an emty string is",
  "returned.",
  "",
  "        <len>       A number indicating the number of characters",
  "to be extracted.  If <len> is larger than the (len(<string>) - <index> + 1),",
  "then (len(<string>) - <index> + 1) characters are returned.",
  "",
  "    Example:    set str=\"$%64$%65$%73$%78\"  # \"desh\"",
  "                set ix=2",
  "                set nch=2",
  "                set mstr=mid(str,ix,nch)",
  "                echo str=$str mid(str,ix,nch)=$mstr",
  "",
  "                    This example displays:",
  "",
  "                        str=desh mid(str,ix,nch)=es",
  "",
  "See also:        _left_, _len_, _right_",
NULL
};

static char * chelp_text_now[] = {
  "now built-in expression function",
  "",
  "Returns the current date and time.",
  "",
  "    Syntax:     <date> = now(<fmt>)",
  "",
  "        <fmt>       The output date format of the addtodate() result.",
  "See _datefmts_ for information on date formats.",
  "",
  "    Example:    copy -y myFile myFileBKUP${now(\"%y%m%d\")}",
  "",
  "                    This example makes a backup copy of myFile",
  "using the current date.  The backup is named myFileBKUPyymmdd.",
  "",
  "See also:        _addtodate_, _datefmts_, _subdates_, _subfromdate_",
NULL
};

static char * chelp_text_prompt[] = {
  "prompt built-in expression function",
  "",
  "Returns characters entered by user.",
  "",
  "    Syntax:     <response> = prompt(<prompt-string>)",
  "",
  "        <response>          The character string entered by the user.",
  "The response is read from stdin and is terminated by an ENTER",
  "key or newline.",
  "",
  "        <prompt-string>     A string that is displayed prior",
  "to the user input.  If stdin is not a terminal (e.g. a file), then",
  "no prompt string is displayed.",
  "",
  "    Example:    set answer=prompt(\"Which option do you choose?\")",
  "",
  "                    This example displays the option entered by the user.",
  "",
  "See also:        _len_, _variables_",
  "",
NULL
};

static char * chelp_text_rept[] = {
  "rept built-in expression function",
  "",
  "Creates a new string by repeating the characters of a string.",
  "",
  "    Syntax:     <str> = rept(<string>, <num>)",
  "",
  "        <str>       String returned by rept().",
  "",
  "        <string>    The string to be repeated.",
  "",
  "        <num>       A number indicating the number of times <string>",
  "is to repeated.  If <num> is less than or equal to zero,",
  "an empty string is returned.",
  "",
  "    Note:       The total length of the result string may not be",
  "greater than one megabyte (1,048,576 bytes).",
  "",
  "    Example:    set str=\"<>\"",
  "                set nrpt=3",
  "                set rstr=rept(str,nrpt)",
  "                echo str=$str rept(str,$nrpt)=$rstr",
  "",
  "                    This example displays:",
  "",
  "                        str=<> rept(str,3)=<><><>",
  "",
  "See also:        _len_",
NULL
};

static char * chelp_text_right[] = {
  "right built-in expression function",
  "",
  "Returns characters from the right of a string.",
  "",
  "    Syntax:     <substr> = right(<string>, <len>)",
  "",
  "        <substr>    String returned by right().",
  "",
  "        <string>    The source string from which the rightmost",
  "characters are extracted.",
  "",
  "        <len>       A number indicating the number of characters",
  "to be extracted.  If <len> is larger than the length of <string>,",
  "the entire <string> is returned.",
  "",
  "    Example:    set str=\"$%64$%65$%73$%78\"  # \"desh\"",
  "                set nch=3",
  "                set rstr=right(str,nch)",
  "                echo str=$str right(str,nch)=$rstr",
  "",
  "                    This example displays:",
  "",
  "                        str=desh right(str,nch)=esh",
  "",
  "See also:        _left_, _len_, _mid_",
NULL
};

static char * chelp_text_subdates[] = {
  "subdates built-in expression function",
  "",
  "Subtracts two dates and returns an interval.",
  "All arguments are expressed as strings, with additional arguments used",
  "to describe the date formats.",
  "",
  "    Syntax:     <intvl> = subdates(<date1>,<fmt1>,<date2>,<fmt2>,<fmt>)",
  "",
  "        <intvl>     Return value of subdates() in the date format",
  "specified by <fmt>.",
  "",
  "        <date1>     The date origin from which <date2> is",
  "subtracted.  This date must be in the format specified by <fmt1>.",
  "",
  "        <fmt1>      The date format of <frdat>.  See _datefmts_",
  "for information on date formats.",
  "",
  "        <date2>     The date to be subtracted from <date1>.",
  "This date must be in the format specified by <fmt2>.",
  "",
  "        <fmt2>      The format of <intvl>.  See _datefmts_",
  "for information on date formats.",
  "",
  "        <fmt>    The output date format of the subdates() result.",
  "See _datefmts_ for information on date formats.",
  "",
  "    Example:    set datfmt=\"%Y-%m-%d\"",
  "                set dat1=\"2012-12-31\"",
  "                set dat2=\"2012-01-01\"",
  "                set ndays=subdates(dat1, datfmt, dat2, datfmt, \"%nd\")",
  "",
  "                    This example sets ndays to the number of days",
  "between December 31, 2012 and January 1, 2012 which is 365.",
  "",
  "See also:        _addtodate_, _datefmts_, _now_, _subfromdate_",
NULL
};

static char * chelp_text_subfromdate[] = {
  "subfromdate built-in expression function",
  "",
  "Subtracts an interval from a date and returns a date.",
  "All arguments are expressed as strings, with additional arguments used",
  "to describe the date formats.",
  "",
  "    Syntax:     <date> = subfromdate(<frdat>,<frfmt>,<intvl>,<ifmt>,<fmt>)",
  "",
  "        <date>      Return value of subfromdate() in the date format",
  "specified by <fmt>.",
  "",
  "        <frdat>     The date origin from which the interval is",
  "subtracted.  This date must be in the format specified by <frfmt>.",
  "",
  "        <frfmt>     The date format of <frdat>.  See _datefmts_",
  "for information on date formats.",
  "",
  "        <intvl>     The interval to be subtracted from <frdate>.",
  "This interval must be in the format specified by <ifmt>.",
  "",
  "        <ifmt>      The format of <intvl>.  See _datefmts_",
  "for information on date formats.",
  "",
  "        <fmt>    The output date format of the addtodate() result.",
  "See _datefmts_ for information on date formats.",
  "",
  "    Example:    set datfmt=\"%Y%m%d\"",
  "                set today=now(datfmt)",
  "                set yesterday=subfromdate(today, datfmt, 1, \"%nd\", datfmt)",
  "",
  "                    This example calculates the value of yesterday",
  "in YYYYMMDD format by subtracting one day from the current date.",
  "",
  "See also:        _addtodate_, _datefmts_, _now_, _subdates_",
NULL
};

static char * chelp_text_trim[] = {
  "trim built-in expression function",
  "",
  "Strips leading and trailing whitespace characters from a string.",
  "Whitespace is any one of four characters: space, tab, carriage",
  "return, or linefeed.",
  "",
  "    Syntax:     <trimstr> = trim(<string>)",
  "",
  "        <trimstr>   String stripped of leading and trailing",
  "whitespace returned by trim().",
  "",
  "        <string>    The source string from which leading and trailing",
  "spaces are removed.",
  "",
  "    Example:    set str=\"    Alpha beta      gamma    \"",
  "                set tstr=trim(str)",
  "                echo len(str)=${len(str)} str=$str=",
  "                echo len(tstr)=${len(tstr)} tstr=$tstr=",
  "",
  "                    This example displays:",
  "",
  "                        len(str)=29 str=    Alpha beta      gamma    =",
  "                        len(tstr)=21 tstr=Alpha beta      gamma=",
  "",
  "See also:        _len_, _mid_",
NULL
};

static char * chelp_text_upper[] = {
  "upper built-in expression function",
  "",
  "Returns the string in all upper case characters.",
  "",
  "    Syntax:     <upstr> = upper(<string>)",
  "",
  "        <upstr>     The <string> with all lower case",
  "characters converted to upper case.",
  "",
  "        <string>    The source string.",
  "",
  "    Example:    set str=\"Alpha Beta Gamma\"",
  "                set low=upper(str)",
  "                echo str=$str upper(str)=$low",
  "",
  "                    This example displays:",
  "",
  "                        str=Alpha Beta Gamma upper(str)=ALPHA BETA GAMMA",
  "",
  "See also:        _lower_",
NULL
};

/***************************************************************/
char ** get_help_lines(const char * help_item) {

    char ** chelp_lines = NULL;

         if (!strcmp(help_item, "index"         )) chelp_lines = chelp_text_index;
    else if (!strcmp(help_item, "commands"      )) chelp_lines = chelp_text_commands;
    else if (!strcmp(help_item, "errors"        )) chelp_lines = chelp_text_errors;
    else if (!strcmp(help_item, "datefmts"      )) chelp_lines = chelp_text_datefmts;
    else if (!strcmp(help_item, "desh"          )) chelp_lines = chelp_text_desh;
    else if (!strcmp(help_item, "expfunctions"  )) chelp_lines = chelp_text_expfunctions;
    else if (!strcmp(help_item, "expressions"   )) chelp_lines = chelp_text_expressions;
    else if (!strcmp(help_item, "intro"         )) chelp_lines = chelp_text_intro;
    else if (!strcmp(help_item, "keyboard"      )) chelp_lines = chelp_text_keyboard;
    else if (!strcmp(help_item, "parsing"       )) chelp_lines = chelp_text_parsing;
    else if (!strcmp(help_item, "redirection"   )) chelp_lines = chelp_text_redirection;
    else if (!strcmp(help_item, "scripting"     )) chelp_lines = chelp_text_scripting;
    else if (!strcmp(help_item, "shells"        )) chelp_lines = chelp_text_shells;
    else if (!strcmp(help_item, "substitution"  )) chelp_lines = chelp_text_substitution;
    else if (!strcmp(help_item, "userfunctions" )) chelp_lines = chelp_text_userfunctions;
    else if (!strcmp(help_item, "variables"     )) chelp_lines = chelp_text_variables;
    else if (!strcmp(help_item, "call"          )) chelp_lines = chelp_text_call;
    else if (!strcmp(help_item, "catch"         )) chelp_lines = chelp_text_catch;
    else if (!strcmp(help_item, "cd"            )) chelp_lines = chelp_text_cd;
    else if (!strcmp(help_item, "chmod"         )) chelp_lines = chelp_text_chmod;
    else if (!strcmp(help_item, "copy"          )) chelp_lines = chelp_text_copy;
    else if (!strcmp(help_item, "dir"           )) chelp_lines = chelp_text_dir;
    else if (!strcmp(help_item, "dot"           )) chelp_lines = chelp_text_dot;
    else if (!strcmp(help_item, "echo"          )) chelp_lines = chelp_text_echo;
    else if (!strcmp(help_item, "else"          )) chelp_lines = chelp_text_else;
    else if (!strcmp(help_item, "endfor"        )) chelp_lines = chelp_text_endfor;
    else if (!strcmp(help_item, "endfunction"   )) chelp_lines = chelp_text_endfunction;
    else if (!strcmp(help_item, "endif"         )) chelp_lines = chelp_text_endif;
    else if (!strcmp(help_item, "endtry"        )) chelp_lines = chelp_text_endtry;
    else if (!strcmp(help_item, "endwhile"      )) chelp_lines = chelp_text_endwhile;
    else if (!strcmp(help_item, "exit"          )) chelp_lines = chelp_text_exit;
    else if (!strcmp(help_item, "export"        )) chelp_lines = chelp_text_export;
    else if (!strcmp(help_item, "for"           )) chelp_lines = chelp_text_for;
    else if (!strcmp(help_item, "function"      )) chelp_lines = chelp_text_function;
    else if (!strcmp(help_item, "help"          )) chelp_lines = chelp_text_help;
    else if (!strcmp(help_item, "if"            )) chelp_lines = chelp_text_if;
    else if (!strcmp(help_item, "mkdir"         )) chelp_lines = chelp_text_mkdir;
    else if (!strcmp(help_item, "move"          )) chelp_lines = chelp_text_move;
    else if (!strcmp(help_item, "remove"        )) chelp_lines = chelp_text_remove;
    else if (!strcmp(help_item, "removedir"     )) chelp_lines = chelp_text_removedir;
    else if (!strcmp(help_item, "return"        )) chelp_lines = chelp_text_return;
    else if (!strcmp(help_item, "rmdir"         )) chelp_lines = chelp_text_rmdir;
    else if (!strcmp(help_item, "set"           )) chelp_lines = chelp_text_set;
    else if (!strcmp(help_item, "shift"         )) chelp_lines = chelp_text_shift;
    else if (!strcmp(help_item, "shopt"         )) chelp_lines = chelp_text_shopt;
    else if (!strcmp(help_item, "start"         )) chelp_lines = chelp_text_start;
    else if (!strcmp(help_item, "throw"         )) chelp_lines = chelp_text_throw;
    else if (!strcmp(help_item, "time"          )) chelp_lines = chelp_text_time;
    else if (!strcmp(help_item, "try"           )) chelp_lines = chelp_text_try;
    else if (!strcmp(help_item, "type"          )) chelp_lines = chelp_text_type;
    else if (!strcmp(help_item, "wait"          )) chelp_lines = chelp_text_wait;
    else if (!strcmp(help_item, "while"         )) chelp_lines = chelp_text_while;
    else if (!strcmp(help_item, "addtodate"     )) chelp_lines = chelp_text_addtodate;
    else if (!strcmp(help_item, "argv"          )) chelp_lines = chelp_text_argv;
    else if (!strcmp(help_item, "basename"      )) chelp_lines = chelp_text_basename;
    else if (!strcmp(help_item, "char"          )) chelp_lines = chelp_text_char;
    else if (!strcmp(help_item, "chbase"        )) chelp_lines = chelp_text_chbase;
    else if (!strcmp(help_item, "code"          )) chelp_lines = chelp_text_code;
    else if (!strcmp(help_item, "dirname"       )) chelp_lines = chelp_text_dirname;
    else if (!strcmp(help_item, "extname"       )) chelp_lines = chelp_text_extname;
    else if (!strcmp(help_item, "find"          )) chelp_lines = chelp_text_find;
    else if (!strcmp(help_item, "finfo"         )) chelp_lines = chelp_text_finfo;
    else if (!strcmp(help_item, "left"          )) chelp_lines = chelp_text_left;
    else if (!strcmp(help_item, "len"           )) chelp_lines = chelp_text_len;
    else if (!strcmp(help_item, "lower"         )) chelp_lines = chelp_text_lower;
    else if (!strcmp(help_item, "matches"       )) chelp_lines = chelp_text_matches;
    else if (!strcmp(help_item, "mid"           )) chelp_lines = chelp_text_mid;
    else if (!strcmp(help_item, "now"           )) chelp_lines = chelp_text_now;
    else if (!strcmp(help_item, "prompt"        )) chelp_lines = chelp_text_prompt;
    else if (!strcmp(help_item, "rept"          )) chelp_lines = chelp_text_rept;
    else if (!strcmp(help_item, "right"         )) chelp_lines = chelp_text_right;
    else if (!strcmp(help_item, "subdates"      )) chelp_lines = chelp_text_subdates;
    else if (!strcmp(help_item, "subfromdate"   )) chelp_lines = chelp_text_subfromdate;
    else if (!strcmp(help_item, "trim"          )) chelp_lines = chelp_text_trim;
    else if (!strcmp(help_item, "upper"         )) chelp_lines = chelp_text_upper;

    return (chelp_lines);
}
/***************************************************************/
